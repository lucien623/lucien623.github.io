<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucien</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-18T13:04:08.408Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lucien</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OkHttp原理探析</title>
    <link href="http://yoursite.com/2019/10/18/OkHttp%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/18/OkHttp原理探析/</id>
    <published>2019-10-18T06:34:28.000Z</published>
    <updated>2019-10-18T13:04:08.408Z</updated>
    
    <content type="html"><![CDATA[<p><code>OkHttp</code>是最近几年在安卓开发中运用比较广泛的开源网络框架，支持同步和异步请求，本文主要分析平常开发中运用得比较多的异步请求流程。首先来看下开启一个异步请求的流程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</div></pre></td></tr></table></figure></p>
<p>第一步创建<code>OkHttpClient</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">"https://lucien623.github.io/"</span>).build();</div></pre></td></tr></table></figure></p>
<p>第二步创建<code>Request</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>第三步调用<code>okHttpClient</code>的<code>newCall</code>方法，并把<code>request</code>传入，再接着调用<code>enqueue</code>方法即开始异步请求了。<br>先暂时不分析<code>OkHttpClient</code>这个类，来看看<code>Request</code>的创建过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    HttpUrl url;</div><div class="line">    String method;</div><div class="line">    Headers.Builder headers;</div><div class="line">    RequestBody body;</div><div class="line">    Object tag;</div><div class="line"></div><div class="line">    <span class="comment">//...此处省略部分代码</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">url</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"url == null"</span>);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"ws:"</span>, <span class="number">0</span>, <span class="number">3</span>)) &#123;</div><div class="line">        url = <span class="string">"http:"</span> + url.substring(<span class="number">3</span>);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"wss:"</span>, <span class="number">0</span>, <span class="number">4</span>)) &#123;</div><div class="line">        url = <span class="string">"https:"</span> + url.substring(<span class="number">4</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      HttpUrl parsed = HttpUrl.parse(url);</div><div class="line">      <span class="keyword">if</span> (parsed == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unexpected url: "</span> + url);</div><div class="line">      <span class="keyword">return</span> url(parsed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>就是通过建造者模式构建一个实例，对我们传入的<code>URL</code>地址进行了一个判断，如果是<code>web socket</code>形式的地址，会被转换成<code>http</code>或<code>https</code>形式的地址，<br>接着我们来看看<code>newCall(request)</code>过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到构建返回了一个<code>RealCall</code>实例，<code>newCall</code>方法其实是定义在<code>Call</code>接口中的工厂方法接口，接着看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">RealCall(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket) &#123;</div><div class="line">  <span class="keyword">final</span> EventListener.Factory eventListenerFactory = client.eventListenerFactory();</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.client = client;</div><div class="line">  <span class="keyword">this</span>.originalRequest = originalRequest;</div><div class="line">  <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">  <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</div><div class="line"></div><div class="line">  <span class="comment">// TODO(jwilson): this is unsafe publication and not threadsafe.</span></div><div class="line">  <span class="keyword">this</span>.eventListener = eventListenerFactory.create(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>RealCall</code>实例包含了之前创建的<code>OkHttpClient</code>和<code>Request</code>实例，并创建了一个<code>RetryAndFollowUpInterceptor</code>拦截器，这个我们之后可以分析到，<code>RealCall</code>实现了<code>Call</code>接口中的方法，包括接下来要调用<code>RealCall</code>中的<code>enqueue</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先会判断当前的<code>RealCall</code>对象是否已经执行过同步或者异步方法，如果执行过的会就会抛出”Already Executed”的异常，这一步可以得出每一个创建的<code>Call</code>都只能够执行一次请求，接着我们可以看到调用<code>client.dispatcher()</code>执行了<code>enqueue</code>方法，就是通过<code>OkHttpClient</code>实例获取到了一个<code>Dispatcher</code>实例，然后再调用这个方法，我们暂时不管<code>Dispatcher</code>，先看<code>new AsyncCall(responseCallback)</code>是个啥，<code>responseCallback</code>是我们在调用异步请求方法的时候传递的一个回调，接着看<code>AsyncCall</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</div><div class="line"></div><div class="line">  AsyncCall(Callback responseCallback) &#123;</div><div class="line">    <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</div><div class="line">    <span class="keyword">this</span>.responseCallback = responseCallback;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> originalRequest.url().host();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> originalRequest;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Response response = getResponseWithInterceptorChain();</div><div class="line">      <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">        signalledCallback = <span class="keyword">true</span>;</div><div class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        signalledCallback = <span class="keyword">true</span>;</div><div class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      <span class="keyword">if</span> (signalledCallback) &#123;</div><div class="line">        <span class="comment">// Do not signal the callback twice!</span></div><div class="line">        Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>NamedRunnable</code>其实就是个实现了<code>Runnable</code>接口的抽象类，在<code>NamedRunnable</code>重写的<code>run()</code>方法中调用了<code>AsyncCall</code>中的<code>execute();</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  String oldName = Thread.currentThread().getName();</div><div class="line">  Thread.currentThread().setName(name);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    execute();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    Thread.currentThread().setName(oldName);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个时候我们就大致可以知道<code>Dispatcher</code>里面肯定有个<code>Thread</code>，或者线程池了，其实他就是个任务调度器，英文的字面意思不就是这样么= =，我们接着看它调用<code>enqueue</code>方法是怎么执行的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">    runningAsyncCalls.add(call);</div><div class="line">    executorService().execute(call);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    readyAsyncCalls.add(call);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Dispatcher</code>实例是在创建<code>OkHttpClient</code>时 new 的，初始化时创建了三个队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Ready async calls in the order they'll be run. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p><code>readyAsyncCalls</code>表示等待执行异步请求队列，<code>runningAsyncCalls</code>是正在执行异步请求中的队列，<code>runningSyncCalls</code>是正在执行同步请求的队列，再回到上面先判断当前正在执行异步请求的数量有没有小于最大的异步请求数<code>maxRequests</code>即 64 个，然后判断当前<code>host</code>的异步请求数是否超过了<code>maxRequestsPerHost</code>即 5 个，如果不满足其中一个条件就把<code>call</code>放入待执行异步任务队列中，如果同时满足的话，就把当前的<code>call</code>放入正在执行异步请求队列中，然后执行<code>executorService().execute(call);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</div><div class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</div><div class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>终于线程池的真面目露出来了，这里创建了一个线程池大小为<code>Integer.MAX_VALUE</code>即 2^31 - 1，如果有线程闲置 60 秒即被回收，内部没有任何容量的阻塞队列（核心线程都木有当然不需要任何容量了）的线程池，<code>AsyncCall</code>交由线程池之后会开启子线程执行异步请求，然后会执行<code>execute()</code>方法，接着来看<code>Response response = getResponseWithInterceptorChain();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">// Build a full stack of interceptors.</span></div><div class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  interceptors.addAll(client.interceptors());</div><div class="line">  interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">    interceptors.addAll(client.networkInterceptors());</div><div class="line">  &#125;</div><div class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</div><div class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到这里创建了一堆拦截器放到了集合里，然后和<code>originalRequest</code>实例一起构建了<code>RealInterceptorChain</code>，最后将执行<code>chain.proceed(originalRequest)</code>的结果返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></div><div class="line">    RealConnection connection) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line"></div><div class="line">  calls++;</div><div class="line"></div><div class="line">   <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">  <span class="comment">// Call the next interceptor in the chain.</span></div><div class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</div><div class="line">  Interceptor interceptor = interceptors.get(index);</div><div class="line">  Response response = interceptor.intercept(next);</div><div class="line"></div><div class="line">   <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>proceed</code>方法中又构建了一个<code>RealInterceptorChain</code>实例，<code>index</code>值加 1，接着获取对应 index 位置的<code>Interceptor</code>实例，前面我们可以看到第一个拦截器是<code>retryAndFollowUpInterceptor</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = chain.request();</div><div class="line"></div><div class="line">    streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">        client.connectionPool(), createAddress(request.url()), callStackTrace);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</div><div class="line">    Response priorResponse = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (canceled) &#123;</div><div class="line">        streamAllocation.release();</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Response response = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        releaseConnection = <span class="keyword">false</span>;</div><div class="line">      &#125; </div><div class="line">      <span class="comment">//...此处省略部分代码</span></div><div class="line">      <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></div><div class="line">        <span class="keyword">if</span> (releaseConnection) &#123;</div><div class="line">          streamAllocation.streamFailed(<span class="keyword">null</span>);</div><div class="line">          streamAllocation.release();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></div><div class="line">      <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</div><div class="line">        response = response.newBuilder()</div><div class="line">            .priorResponse(priorResponse.newBuilder()</div><div class="line">                    .body(<span class="keyword">null</span>)</div><div class="line">                    .build())</div><div class="line">            .build();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Request followUp = followUpRequest(response);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">          streamAllocation.release();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      closeQuietly(response.body());</div><div class="line">	  <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</div><div class="line">        streamAllocation.release();</div><div class="line">        streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">            client.connectionPool(), createAddress(followUp.url()), callStackTrace);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</div><div class="line">            + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      request = followUp;</div><div class="line">      priorResponse = response;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这个拦截器功能是根据<code>response</code>来做相应的处理，<code>followUpRequest(response)</code>这个方法里会根据<code>responseCode</code>判断是否需要重新构建<code>Request</code>，默认请求成功的话会返回<code>null</code>，如果发生类似请求重定向之类的，那么便会重新构建<code>Request</code>实例返回，可以看到这里面是一个<code>while (true)</code>循环，那么用重新构建的<code>request</code>再走循环里的逻辑，包括<code>response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</code>也就是说会再次进行网络请求获取<code>response</code>。那么继续来看<code>proceed</code>，此时的<code>chain</code>是之前创建的<code>index = 1</code>的<code>RealInterceptorChain</code>实例，此时在<code>proceed</code>方法中获取的到的<code>Interceptor</code>是<code>BridgeInterceptor</code>实例，这个拦截器的作用就是把我们构造的请求转换成发送至服务器的请求以及将服务端返回的响应转换成用户友好的响应，这个拦截器的代码就不详细分析了，拦截器这里其实就是运用了责任链模式，每一个拦截器都可以对<code>request</code>和<code>response</code>进行处理，这样的设计是<code>OkHttp</code>比较精妙的一个地方。ok，那么接下来我们再看看缓存拦截器<code>CacheInterceptor</code>里的<code>intercept(Chain chain)</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Response cacheCandidate = cache != <span class="keyword">null</span></div><div class="line">    ? cache.get(chain.request())</div><div class="line">    : <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<p>首先判断<code>cache</code>实例是否为<code>null</code>，如果我们创建<code>OkHttpClient</code>实例时传入了自己的缓存实例的话，会调用<code>get</code>方法，缓存其实是用<code>DiskLruCache</code>形式保存的，key 是以请求<code>url</code>的 md5 值的形式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</div><div class="line">Request networkRequest = strategy.networkRequest;</div><div class="line">Response cacheResponse = strategy.cacheResponse;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  CacheStrategy candidate = getCandidate();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</div><div class="line">    <span class="comment">// We're forbidden from using the network and the cache is insufficient.</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> candidate;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步是根据请求和缓存<code>Response</code>获取缓存策略，继续看<code>getCandidate()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// No cached response.</span></div><div class="line">  <span class="comment">// 没有缓存</span></div><div class="line">  <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Drop the cached response if it's missing a required handshake.</span></div><div class="line">  <span class="comment">// 丢失握手信息</span></div><div class="line">  <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 根据返回状态吗和 Cache-control 策略判断是否可以缓存</span></div><div class="line">  <span class="comment">// 像比如说response header 里cache-control: no-cache, no-store是这样的 那么会返回 false</span></div><div class="line">  <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//根据请求头判断是否是不需要 cache</span></div><div class="line">  CacheControl requestCaching = request.cacheControl();</div><div class="line">  <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> ageMillis = cacheResponseAge();</div><div class="line">  <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</div><div class="line">    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</div><div class="line">    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</div><div class="line">  CacheControl responseCaching = cacheResponse.cacheControl();</div><div class="line">  <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</div><div class="line">    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</div><div class="line">    Response.Builder builder = cacheResponse.newBuilder();</div><div class="line">    <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</div><div class="line">      builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"110 HttpURLConnection \"Response is stale\""</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</div><div class="line">    <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</div><div class="line">      builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"113 HttpURLConnection \"Heuristic expiration\""</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里表示如果缓存没有过期，那么根据 cacheResponse 创建一个 Response</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//如果缓存过期，且有 etag 信息，则判断条件放到请求头里请求提交服务器</span></div><div class="line">  String conditionName;</div><div class="line">  String conditionValue;</div><div class="line">  <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</div><div class="line">    conditionName = <span class="string">"If-None-Match"</span>;</div><div class="line">    conditionValue = etag;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</div><div class="line">    conditionName = <span class="string">"If-Modified-Since"</span>;</div><div class="line">    conditionValue = lastModifiedString;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</div><div class="line">    conditionName = <span class="string">"If-Modified-Since"</span>;</div><div class="line">    conditionValue = servedDateString;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</div><div class="line">  Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</div><div class="line"></div><div class="line">  Request conditionalRequest = request.newBuilder()</div><div class="line">      .headers(conditionalRequestHeaders.build())</div><div class="line">      .build();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是根据对<code>CacheStrategy</code>做相应逻辑了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</div><div class="line">      .request(chain.request())</div><div class="line">      .protocol(Protocol.HTTP_1_1)</div><div class="line">      .code(<span class="number">504</span>)</div><div class="line">      .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</div><div class="line">      .body(Util.EMPTY_RESPONSE)</div><div class="line">      .sentRequestAtMillis(-<span class="number">1L</span>)</div><div class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">      .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里表示如果不允许使用网络并且没有缓存的话，就自己构造一个<code>Response</code>返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">return</span> cacheResponse.newBuilder()</div><div class="line">      .cacheResponse(stripBody(cacheResponse))</div><div class="line">      .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一步表示如果不进行网络请求那么返回缓存的<code>cacheResponse</code>，接下来如果需要网络就会执行<code>networkResponse = chain.proceed(networkRequest);</code>了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</div><div class="line">    Response response = cacheResponse.newBuilder()</div><div class="line">        .headers(combine(cacheResponse.headers(), networkResponse.headers()))</div><div class="line">        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</div><div class="line">        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</div><div class="line">        .cacheResponse(stripBody(cacheResponse))</div><div class="line">        .networkResponse(stripBody(networkResponse))</div><div class="line">        .build();</div><div class="line">    networkResponse.body().close();</div><div class="line"></div><div class="line">    <span class="comment">// Update the cache after combining headers but before stripping the</span></div><div class="line">    <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></div><div class="line">    cache.trackConditionalCacheHit();</div><div class="line">    cache.update(cacheResponse, response);</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    closeQuietly(cacheResponse.body());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>拿到网络请求返回的<code>networkResponse</code>后，判断是不是返回 304，如果是的话就把<code>cacheResponse</code>的请求头和<code>networkResponse</code>的请求合并，然后更新<code>Response</code>缓存，接下来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Response response = networkResponse.newBuilder()</div><div class="line">    .cacheResponse(stripBody(cacheResponse))</div><div class="line">    .networkResponse(stripBody(networkResponse))</div><div class="line">    .build();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</div><div class="line">    <span class="comment">// Offer this request to the cache.</span></div><div class="line">    CacheRequest cacheRequest = cache.put(response);</div><div class="line">    <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      cache.remove(networkRequest);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</div><div class="line">      <span class="comment">// The cache cannot be written.</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> response;</div></pre></td></tr></table></figure></p>
<p>接下来根据<code>response</code>里的返回码、method 和内容长度判断是否有需要缓存的 body 内容以及根据<code>response</code>的返回码缓存策略和<code>networkRequest</code>中的缓存策略判断是否需要缓存，如果 body 可以缓存以及策略需要缓存的话，那么会将<code>response</code>存放到<code>cache</code>中。接下来一步是根据网络请求的方式来判断是否需要缓存啦，像类似于”DELETE”、”PUT”之类的请求就没必要添加到缓存里。还有一个<code>CallServerInterceptor</code>就不多讲了，这个拦截器的功能就是向服务器发送请求数据以及获取响应数据。经过这一连串的拦截器处理最后可以获取到<code>Response</code>然后回调返回了～</p>
]]></content>
    
    <summary type="html">
    
      本文是对 OkHttp 原理的简要分析（以异步为例）。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap原理探析</title>
    <link href="http://yoursite.com/2019/10/17/ConcurrentHashMap%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/17/ConcurrentHashMap原理探析/</id>
    <published>2019-10-17T09:27:13.000Z</published>
    <updated>2019-10-17T12:17:54.324Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashMap</code>在我们的开发中可以说是很常见了，主要是用来存储键值对的数据结构，<code>HashMap</code>并不是线程安全的，如果要想实现线程安全，可以使用<code>Collections.synchronizeMap(hashMap)</code>的方式，当然<code>JDK</code>里也以提供了另外一个可以实现并发操作的键值对存储结构，那就是<code>ConcurrentHashMap</code>，那么接下来我们就来探析下他是如何实现线程安全的，看看<code>put</code>方法的实现机制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            tab = initTable();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        binCount = <span class="number">1</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取<code>key</code>到<code>hashCode</code>，调用<code>spread</code>方法，将<code>hashCode</code>的高 16 位和低 16 位进行异或操作，再与<code>HASH_BITS</code>进行与操作，<code>HASH_BITS</code>的值是 0x7fffffff，也就是 32 位带符号的最大整数，效果等同于取余，异或主要是为了降低碰撞的几率。接着进入循环之中，首先判断<code>table</code>是否为空，如果为空的话，则进行初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</div><div class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里其实也用到了<code>Unsafe</code>和 CAS 机制，如果不了解可以自行先去看下，因为我们是用无参构造方法创建的对象，那么<code>sizeCtl</code>变量的值就是 0，然后利用 CAS 操作将<code>sizeCtl</code>设置为 -1，此时若有其他线程进入此方法，则会执行<code>Thread.yield();</code>,使当前线程从运行状态变为就绪状态，再回到创建<code>table</code>的线程，创建了一个起始大小为<code>DEFAULT_CAPACITY = 16;</code>长度的<code>Node</code>数组，并设置<code>sizeCtl</code>的值为 12，到此<code>table</code>就创建完成了。再回到循环中，然后通过与数组长度与运算，根据内存地址判断相应位置上的值是否为空，如果为空的话则通过 CAS 机制对在相应地址上进行赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></div><div class="line">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>赋值成功则跳出当前循环，失败则继续执行循环，即当前的数组上的对应<code>Node</code>已经赋过值，接下来重点看这里<code>synchronized (f)</code>，<code>f</code>是当前数组中的节点，这里也可以看出<code>ConcurrentHashMap</code>是<strong>以数组中的每一个元素作为分段锁的，分段锁的个数即为数组的长度</strong>。<code>if (fh &gt;= 0)</code>判断数组中节点的<code>hash</code>值是否大于 0，是的话表示当前的存储方式还是链表，那么会从链表中找是否有<code>key</code>相同的节点，如果有则替换，没有则加入链表尾部。如果值小于 0（确切的值是 -2）的话，表示当前已经用红黑树存储了，插入<code>TreeBin</code>中。接着判断<code>binCount</code>的值，如果大于<code>TREEIFY_THRESHOLD</code>的值即 8，那么执行<code>treeifyBin(tab, i);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</div><div class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (b) &#123;</div><div class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</div><div class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                        TreeNode&lt;K,V&gt; p =</div><div class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</div><div class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</div><div class="line">                            hd = p;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            tl.next = p;</div><div class="line">                        tl = p;</div><div class="line">                    &#125;</div><div class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先判断<code>tab</code>数组的长度，如果小于<code>MIN_TREEIFY_CAPACITY</code>即 64，那么不会进行红黑树的转换，而是会将数组扩容，否则会将数组<code>index</code>处的链表构建成一个<code>TreeBin</code>，即红黑树实例。</p>
]]></content>
    
    <summary type="html">
    
      对 ConcurrentHashMap 的原理探析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags%C3%9F/Java/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock原理探析</title>
    <link href="http://yoursite.com/2019/10/16/ReentrantLock%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/16/ReentrantLock原理探析/</id>
    <published>2019-10-16T07:26:08.000Z</published>
    <updated>2019-10-18T06:41:36.551Z</updated>
    
    <content type="html"><![CDATA[<p>最近在对之前看过的一些源码进行回顾，今天主要是对 ReentrantLock 的源码分析。<br><code>ReentrantLock</code>有两个构造方法，当我们通过无参构造方法创建时，内部会创建的是非公平锁实例，那么本文也以非公平锁的实现机制做分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>加锁的方法其实很简单，只需要调用<code>lock.lock();</code>就行了，接下来看看这个<code>lock()</code>方法里到底执行了啥<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.lock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现接着调用了<code>NonfairSync</code>实例中的<code>lock()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先来看<code>compareAndSetState(0, 1)</code>的逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> U.compareAndSwapInt(<span class="keyword">this</span>, STATE, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>U</code>是<code>Unsafe</code>的实例，那这个类到底是干嘛用的呢，简单来讲，这个类就是用来提供硬件级别的原子操作的，比如通过它你可以获取到某个属性的内存地址。这个地方还牵涉到 CAS(Compare And Swap) 机制，包含三个操作数，内存地址 V， 预期原值 A，新值 B，进行 CAS 操作的时候首先会将内存地址 V 中的值与预期原值 A 比较，如果相同，则将 V 中的值更新为 B，不同则执行相应逻辑，像这里如果 CAS 操作失败的话会返回 false。 <code>STATE</code>是什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">STATE = U.objectFieldOffset</div><div class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</div></pre></td></tr></table></figure></p>
<p>这个变量保存的就是<code>state</code>成员变量的内存地址，这些都定义在<code>NonfairSync</code>的父类<code>AbstractQueuedSynchronizer</code>中，<code>AbstractQueuedSynchronizer</code>是一个基于 FIFO 队列的同步框架，<code>state</code>表示的就是同步状态，如果值为 0 说明没有线程获取锁，反之则说明有线程持有锁。ok，当<code>compareAndSetState(0, 1)</code>返回<code>true</code>时，即表示<code>state</code>之前的值为 0，没有线程持有锁，当前线程获取锁成功，然后执行<code>setExclusiveOwnerThread(Thread.currentThread());</code>把当前线程设置到<code>exclusiveOwnerThread</code>变量中。我们再来看看返回<code>false</code>的情况，执行<code>acquire(1);</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先会调用<code>tryAcquire(arg)</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法是子类<code>NonfairSync</code>来实现的，首先获取<code>state</code>的值，如果是 0，表示之前持有锁的线程已经释放锁了，所以会尝试获取锁，反之不是 0 的话，会先判断当前线程是不是已经持有锁的线程，如果是的话 state 的值继续加 1，这里也说明<code>ReentrantLock</code>是可重入锁。那么我们假如当前线程不是持有锁的线程，所以这个方法最后会返回<code>false</code>，继续执行<code>addWaiter(Node.EXCLUSIVE)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(mode);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node oldTail = tail;</div><div class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</div><div class="line">            U.putObject(node, Node.PREV, oldTail);</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</div><div class="line">                oldTail.next = node;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            initializeSyncQueue();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先创建一个<code>Node</code>实例，会持有当前线程的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Node(Node nextWaiter) &#123;</div><div class="line">    <span class="keyword">this</span>.nextWaiter = nextWaiter;</div><div class="line">    U.putObject(<span class="keyword">this</span>, THREAD, Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是一个<code>for</code>循环，里面会判断尾节点是不是<code>null</code>，如果是<code>null</code>的话，则会初始化队列，并创建一个新的节点，头尾节点都指向它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node h;</div><div class="line">    <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, HEAD, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</div><div class="line">        tail = h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续执行循环中的代码，此时尾节点已经不为<code>null</code>，会把之前持有当前线程节点的前驱指向尾节点，并把这个节点设置成尾节点，原来的尾节点的后驱指向含有当前线程的节点。总结一下就是如果当前没有队列，则创建一个新队列，头节点为没有设置任何值的<code>Node</code>，尾节点为包含当前线程的<code>Node</code>；如果已经有队列的话，则会把创建的含有当前线程的节点放入队列的尾部。当创建的<code>Node</code>放入队列之后，我们再来看看<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        cancelAcquire(node);</div><div class="line">        <span class="keyword">throw</span> t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>循环中首先获取当前节点的前驱节点，判断前驱节点是否为头节点，如果是，执行<code>tryAcquire(arg)</code>方法，尝试获取锁，这里假设仍有其它线程持有锁，那么会执行第二个 if 判断，<code>shouldParkAfterFailedAcquire(p, node)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This node has already set status asking a release</div><div class="line">         * to signal it, so it can safely park.</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Predecessor was cancelled. Skip over predecessors and</div><div class="line">         * indicate retry.</div><div class="line">         */</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class="line">         * need a signal, but don't park yet.  Caller will need to</div><div class="line">         * retry to make sure it cannot acquire before parking.</div><div class="line">         */</div><div class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法用来判断前驱<code>Node</code>的<code>waitStatus</code>，这里会把前驱节点的<code>waitStatus</code>设置成<code>Node.SIGNAL</code>，即等待获取锁的状态，设置成功会返回<code>true</code>，继续执行<code>parkAndCheckInterrupt()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程到这里就被阻塞了。<br><code>lock.unlock();</code>方法的执行流程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看看<code>Sync</code>中<code>tryRelease(arg)</code>的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先判断<code>c</code>的值是否为 0，如果不为 0，则表示返回<code>false</code>，执行结束，这里也说明了如果之前<code>lock()</code>方法被多次调用，那么<code>unlock();</code>也应该的调用相等次数才会尝试释放锁，ok，那么假设这里之前只调用了一次<code>lock()</code>方法，c 的值为 0，获取到<code>head</code>节点，如果头节点不为空，并且<code>waitStatus</code>不等于 0，执行<code>unparkSuccessor(h);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If status is negative (i.e., possibly needing signal) try</div><div class="line">     * to clear in anticipation of signalling.  It is OK if this</div><div class="line">     * fails or if status is changed by waiting thread.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Thread to unpark is held in successor, which is normally</div><div class="line">     * just the next node.  But if cancelled or apparently null,</div><div class="line">     * traverse backwards from tail to find the actual</div><div class="line">     * non-cancelled successor.</div><div class="line">     */</div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</div><div class="line">            <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们把头节点作为参数传入方法中，首先判断<code>waitStatus</code>的值，之前我们设置过的等待获取锁的状态的值为<code>-1</code>是小于 0 的，然后把头节点的<code>waitStatus</code>的值通过 CAS 值设置为 0，获取头节点的后驱节点，即刚才我们为获取到锁的子线程节点，最后刚才阻塞的节点被唤醒，我们会到刚才阻塞住的地方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        cancelAcquire(node);</div><div class="line">        <span class="keyword">throw</span> t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>唤醒之后会继续执行<code>for</code>循环里的逻辑，如果当前节点的前驱节点是节点，然后调用<code>tryAcquire(arg)</code>方法就可以获取到锁了，<code>setHead(node);</code>会把当前节点里面的前驱节点变量和当前持有线程的变量设置为<code>null</code>，当前节点会变成<code>head</code>节点。</p>
<p>非公平锁的逻辑大致就是如此了，<code>ReentrantLock</code>里不是还有个公平锁<code>FairSync</code>么，区别就在与非公平锁调用<code>lock()</code>就会执行<code>compareAndSetState(0, 1)</code>尝试获取锁，而公平锁<code>FairSync</code>则会判断当前是否有线程持有锁，没有的话还会判断当前队列是否存在等待获取锁的节点，有的话会把当前线程的<code>Node</code>放入队尾，一开始并不会去尝试获取锁。</p>
]]></content>
    
    <summary type="html">
    
      对 ReentrantLock 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>RxJava原理探析</title>
    <link href="http://yoursite.com/2019/10/15/RxJava%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/15/RxJava原理探析/</id>
    <published>2019-10-15T03:43:55.000Z</published>
    <updated>2019-10-16T02:15:19.989Z</updated>
    
    <content type="html"><![CDATA[<p>先来看如何创建<code>Observable</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		e.onNext(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>通过调用<code>Observable</code>中的<code>create</code>静态方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</div><div class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终返回的是一个<code>ObservableCreate</code>实例，它关联了一个我们创建的<code>ObservableOnSubscribe</code>实例，<code>ObservableCreate</code>是<code>Observable</code>的子类。<br>接着创建<code>Observer</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observer observer = <span class="keyword">new</span> Observer() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>接下来调用<code>observable.subscribe(observer);</code>，我们来看看<code>subscribe</code>方法中做了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</div><div class="line"></div><div class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</div><div class="line"></div><div class="line">        subscribeActual(observer);</div><div class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        Exceptions.throwIfFatal(e);</div><div class="line">        <span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></div><div class="line">        <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></div><div class="line">        RxJavaPlugins.onError(e);</div><div class="line"></div><div class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</div><div class="line">        npe.initCause(e);</div><div class="line">        <span class="keyword">throw</span> npe;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要的就是<code>subscribeActual(observer);</code>这一步，它的实现在<code>ObservableCreate</code>类中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">       CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</div><div class="line">       observer.onSubscribe(parent);</div><div class="line"></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           source.subscribe(parent);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">           Exceptions.throwIfFatal(ex);</div><div class="line">           parent.onError(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到这个方法里首先创建了一个<code>CreateEmitter</code>实例，并把<code>observer</code>关联起来，然后调用<code>observer.onSubscribe(parent);</code>，即执行了我们开始创建<code>Observer</code>时候实现的<code>onSubscribe(Disposable d)</code>方法，并把<code>CreateEmitter</code>实例传递进去。这个<code>CreateEmitter</code>实现了<code>Disposable</code>接口。接下来执行<code>source.subscribe(parent);</code>即调用我们一开始创建<code>obervable</code>实例时 new 的<code>ObservableOnSubscribe</code>实例的<code>subscribe</code>方法，此时执行<code>e.onNext(1);</code>，即<code>CreateEmitter</code>中的<code>onNext</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">        onError(<span class="keyword">new</span> NullPointerException(<span class="string">"onNext called with null. Null values are generally not allowed in 2.x operators and sources."</span>));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</div><div class="line">        observer.onNext(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到最后还是调用了<code>observer.onNext(t);</code>。<br>接下来看看 RxJava 是如何进行线程切换的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">observable</div><div class="line">   .subscribeOn(Schedulers.io())</div><div class="line">   .observeOn(AndroidSchedulers.mainThread())</div><div class="line">   .subscribe(observer);</div></pre></td></tr></table></figure></p>
<p>这里添加了两行代码，<code>Schedulers.io()</code>返回是一个<code>IoScheduler</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</div><div class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即把当前的<code>Observable</code>和<code>IoScheduler</code>实例关联到新创建的<code>ObservableSubscribeOn</code>实例中去，最后返回这个实例，这个类也是继承于<code>Observable</code>的。此时如果调用<code>.subscribe(observer)</code>，那么会走到这里<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);</div><div class="line"></div><div class="line">    s.onSubscribe(parent);</div><div class="line"></div><div class="line">    parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和之前类似，先是把<code>Observer</code>实例关联到新创建的<code>SubscribeOnObserver</code>实例中，然后调用<code>Observer</code>实例的<code>onSubscribe</code>方法，然后创建一个<code>SubscribeTask</code>实例，关联实例<code>parent</code>，这个<code>SubscribeTask</code>是一个实现了<code>Runnable</code>接口的类，<code>run()</code>中执行了<code>source.subscribe(parent);</code>这时就大概可以猜到它会放到一个子线程里去执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</div><div class="line"></div><div class="line">    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        source.subscribe(parent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着看<code>scheduler.scheduleDirect(new SubscribeTask(parent))</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Worker w = createWorker();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</div><div class="line"></div><div class="line">    DisposeTask task = <span class="keyword">new</span> DisposeTask(decoratedRun, w);</div><div class="line"></div><div class="line">    w.schedule(task, delay, unit);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> task;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来看<code>IoScheduler</code>中<code>createWorker()</code>是怎么实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventLoopWorker(pool.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pool.get()</code>是获取<code>CachedWorkerPool</code>实例，是个实例在<code>IoScheduler</code>实例初始化的时候被创建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    CachedWorkerPool update = <span class="keyword">new</span> CachedWorkerPool(KEEP_ALIVE_TIME, KEEP_ALIVE_UNIT, threadFactory);</div><div class="line">    <span class="keyword">if</span> (!pool.compareAndSet(NONE, update)) &#123;</div><div class="line">        update.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>CachedWorkerPool</code>顾名思义就是<code>ThreadWorker</code>的缓存池，用<code>ConcurrentLinkedQueue</code>保存，接着<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompositeDisposable tasks;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CachedWorkerPool pool;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadWorker threadWorker;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> AtomicBoolean once = <span class="keyword">new</span> AtomicBoolean();</div><div class="line"></div><div class="line">    EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class="line">        <span class="keyword">this</span>.pool = pool;</div><div class="line">        <span class="keyword">this</span>.tasks = <span class="keyword">new</span> CompositeDisposable();</div><div class="line">        <span class="keyword">this</span>.threadWorker = pool.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (once.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">            tasks.dispose();</div><div class="line"></div><div class="line">            <span class="comment">// releasing the pool should be the last action</span></div><div class="line">            pool.release(threadWorker);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> once.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable action, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tasks.isDisposed()) &#123;</div><div class="line">            <span class="comment">// don't schedule, we are unsubscribed</span></div><div class="line">            <span class="keyword">return</span> EmptyDisposable.INSTANCE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造方法里调用了<code>pool.get()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadWorker <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (allWorkers.isDisposed()) &#123;</div><div class="line">        <span class="keyword">return</span> SHUTDOWN_THREAD_WORKER;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!expiringWorkerQueue.isEmpty()) &#123;</div><div class="line">        ThreadWorker threadWorker = expiringWorkerQueue.poll();</div><div class="line">        <span class="keyword">if</span> (threadWorker != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> threadWorker;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// No cached worker found, so create a new one.</span></div><div class="line">    ThreadWorker w = <span class="keyword">new</span> ThreadWorker(threadFactory);</div><div class="line">    allWorkers.add(w);</div><div class="line">    <span class="keyword">return</span> w;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一步其实就是判断缓存队列是不是空的，如果不是，就从中取出一个，否则就创建一个并 add 到<code>allWorkers</code>中。<br>ok，<code>createWorker()</code>这一步终于走完了，接着创建<code>DisposeTask</code>实例并把之前的<code>Worker</code>和<code>Runnable</code>实例关联进去，下一步执行<code>w.schedule(task, delay, unit);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable action, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tasks.isDisposed()) &#123;</div><div class="line">        <span class="comment">// don't schedule, we are unsubscribed</span></div><div class="line">        <span class="keyword">return</span> EmptyDisposable.INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用之前获取到的<code>ThreadWorker</code>实例调用<code>scheduleActual</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="function"><span class="keyword">public</span> ScheduledRunnable <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</div><div class="line">    Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</div><div class="line"></div><div class="line">    ScheduledRunnable sr = <span class="keyword">new</span> ScheduledRunnable(decoratedRun, parent);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!parent.add(sr)) &#123;</div><div class="line">            <span class="keyword">return</span> sr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Future&lt;?&gt; f;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</div><div class="line">            f = executor.submit((Callable&lt;Object&gt;)sr);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</div><div class="line">        &#125;</div><div class="line">        sr.setFuture(f);</div><div class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</div><div class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">            parent.remove(sr);</div><div class="line">        &#125;</div><div class="line">        RxJavaPlugins.onError(ex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，最终提交到<code>executor</code>线程池中执行，最终才会执行<code>source.subscribe(parent);</code><br><code>subscribeOn(Schedulers.io())</code>分析完，接下来看<code>observeOn(AndroidSchedulers.mainThread())</code>是如何执行的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CheckReturnValue</span></div><div class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CheckReturnValue</span></div><div class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</div><div class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</div><div class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里创建了一个<code>ObservableObserveOn</code>实例，继续来看<code>subscribeActual(Observer&lt;? super T&gt; observer)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</div><div class="line">        source.subscribe(observer);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Scheduler.Worker w = scheduler.createWorker();</div><div class="line"></div><div class="line">        source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>scheduler.createWorker();</code>这里返回的是从<code>HandlerScheduler</code>里创建的<code>HandlerWorker(handler)</code>，这个<code>handler</code>是与主线程的<code>looper</code>绑定的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HandlerWorker(handler);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着调用<code>source.subscribe</code>，<code>source</code>就是我们调用<code>.subscribeOn(Schedulers.io())</code>返回的<code>ObservableSubscribeOn</code>实例，回到上面讲过的调用流程了。接下来如果执行<code>e.onNext(1);</code>那么就是调用<code>ObserveOnObserver</code>实例中的<code>onNext</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (done) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</div><div class="line">        queue.offer(t);</div><div class="line">    &#125;</div><div class="line">    schedule();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行<code>schedule();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</div><div class="line">        worker.schedule(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终会执行如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function">ublic Disposable <span class="title">schedule</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (run == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"run == null"</span>);</div><div class="line">   <span class="keyword">if</span> (unit == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit == null"</span>);</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (disposed) &#123;</div><div class="line">       <span class="keyword">return</span> Disposables.disposed();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   run = RxJavaPlugins.onSchedule(run);</div><div class="line"></div><div class="line">   ScheduledRunnable scheduled = <span class="keyword">new</span> ScheduledRunnable(handler, run);</div><div class="line"></div><div class="line">   Message message = Message.obtain(handler, scheduled);</div><div class="line">   message.obj = <span class="keyword">this</span>; <span class="comment">// Used as token for batch disposal of this worker's runnables.</span></div><div class="line"></div><div class="line">   handler.sendMessageDelayed(message, Math.max(<span class="number">0L</span>, unit.toMillis(delay)));</div><div class="line"></div><div class="line">   <span class="comment">// Re-check disposed state for removing in case we were racing a call to dispose().</span></div><div class="line">   <span class="keyword">if</span> (disposed) &#123;</div><div class="line">       handler.removeCallbacks(scheduled);</div><div class="line">       <span class="keyword">return</span> Disposables.disposed();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> scheduled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为我们之前讲过<code>handler</code>是绑定主线程的，然后就会在主线程中执行<code>run()</code> 方法，线程切换就在这里完成，接着执行<code>ObserveOnObserver</code>中的<code>run()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (outputFused) &#123;</div><div class="line">        drainFused();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        drainNormal();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来会走<code>drainNormal();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> missed = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</div><div class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = actual;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">boolean</span> d = done;</div><div class="line">            T v;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                v = q.poll();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                Exceptions.throwIfFatal(ex);</div><div class="line">                s.dispose();</div><div class="line">                q.clear();</div><div class="line">                a.onError(ex);</div><div class="line">                worker.dispose();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (empty) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            a.onNext(v);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        missed = addAndGet(-missed);</div><div class="line">        <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就是从队列中取出消息，然后调用<code>onNext</code>方法。<br>总结：RxJava 的优点在于链式调用，逻辑非常清楚，切换线程也十分方便，也可以随时中断流程。</p>
]]></content>
    
    <summary type="html">
    
      对 RxJava 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask原理探析</title>
    <link href="http://yoursite.com/2019/10/13/AsyncTask%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/13/AsyncTask原理探析/</id>
    <published>2019-10-13T11:17:12.000Z</published>
    <updated>2019-10-15T01:22:18.104Z</updated>
    
    <content type="html"><![CDATA[<p><code>AsyncTask</code>是一个在安卓开发中帮助开发者更简便地创建异步任务的类。先来看简单看一下其用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> AsyncTask&lt;String,Integer,String&gt;()&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPreExecute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPostExecute(s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... strings)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;.execute(<span class="string">"https://cn.bing.com/"</span>);</div></pre></td></tr></table></figure></p>
<p>首先我们来看三个类型参数，第一个<code>Params</code>表示执行任务时传入参数类型，第二个<code>Progress</code>表示后台执行任务更新的进度类型，第三个<code>Result</code>表示后台任务执行结束返回结构的类型。<br>接下来我们来分析下<code>AsyncTask</code>初始化做了些什么。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</div><div class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</div><div class="line">        ? getMainHandler()</div><div class="line">        : <span class="keyword">new</span> Handler(callbackLooper);</div><div class="line"></div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">            Result result = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                <span class="comment">//noinspection unchecked</span></div><div class="line">                result = doInBackground(mParams);</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</div><div class="line">                mCancelled.set(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">throw</span> tr;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postResult(result);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要做了三件事，第一创建<code>InternalHandler</code>类型的对象，这个<code>Handler</code>与主线程的<code>looper</code>绑定；第二创建<code>mWorker</code>对象，<code>WorkerRunnable</code>是一个<code>implements</code>了<code>Callable</code>接口的抽象类，这个<code>Callable</code>接口里定义了一个<code>call()</code>方法，可以看到这个重写的<code>call()</code>方法主要执行的就是异步操作，<code>doInBackground(mParams);</code>就在这里被调用；第三步创建<code>FutureTask</code>对象，<code>FutureTask</code>封装了<code>WorkerRunnable</code>中的<code>call()</code>方法。<br>以调用<code>execute()</code>入口，最后调用的是<code>executeOnExecutor()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一步会判断当前的任务执行状态，如果是正在执行中或者已经执行结束，那么会抛出异常，所以创建的<code>AsyncTask</code>无法多次执行<code>executed()</code>，如果是等待执行状态，那么将状态改为执行中；第二步执行<code>onPreExecute();</code>，也就是我们执行异步任务之前做的准备，这个方法在我们创建异步任务时可以重写添加自己的处理逻辑；第三步将传入的参数赋值给<code>mWorker</code>中的变量；第四步<code>exec.execute(mFuture);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>exec</code>是<code>SerialExecutor</code>的实例，是<code>AsyncTask</code>中的静态变量，类加载的时候被初始化，被所有实例所共有，它其实是一个双端队列，保存着待执行的任务。ok，<code>mFuture</code>加入队列之后，如果没有正在执行的任务，即调用<code>scheduleNext();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">        THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>THREAD_POOL_EXECUTOR</code>是静态代码块创建的一个线程池，这里就是把任务从队列中取出交给线程池执行，最终会调用<code>mWorker</code>的<code>call()</code>方法，<code>doInBackground()</code>执行完返回一个结果最终调用<code>postResult(result);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>getHandler()</code>获取到的是<code>InternalHandler</code>实例，接着看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着调用<code>AsyncTask</code>中的<code>finish(result.mData[0]);</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后调用<code>onPostExecute(result);</code>返回执行结果。<br>我始终还想不明白 Google 工程师设计成串行的目的是为了什么？？？</p>
]]></content>
    
    <summary type="html">
    
      对 AsyncTask 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread原理探析</title>
    <link href="http://yoursite.com/2019/10/12/HandlerThread%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/12/HandlerThread原理探析/</id>
    <published>2019-10-12T11:01:50.000Z</published>
    <updated>2019-10-13T02:23:33.721Z</updated>
    
    <content type="html"><![CDATA[<p><code>HandlerThread</code>是一个可以执行多个异步操作，而不需要创建多线程的类。<code>HandlerThread</code>继承于<code>Thread</code>，是<code>Thread</code>的子类。</p>
<p>如何使用<code>HandlerThread</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler myHandler;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHandlerThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"handlerThread"</span>);</div><div class="line">    handlerThread.start();</div><div class="line">    myHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper()) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="comment">//执行耗时操作</span></div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们要执行某一个耗时操作，就只需要通过<code>myHandler</code>调用<code>sendMessage()</code>方法可以了。<br>那么他是如何实现的呢？首先我们要知道它是一个继承于<code>Thread</code>的类，那么当调用<code>start()</code>方法时就会开启线程，然后执行<code>run()</code>方法，接下来看这个方法是如何被重写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是在子线程里创建一个<code>Looper</code>对象，然后调用<code>loop()</code>方法循环获取消息，那么为什么<code>handleMessage(Message msg)</code>会在子线程里执行呢，我们可以看到其实在构建<code>Handler</code>的时候通过<code>handlerThread.getLooper()</code>将子线程的<code>looper</code>传入了，理所当然<code>loop()</code>中<code>msg.target.dispatchMessage(msg);</code>也会在子线程中执行。</p>
<p>其实在<code>IntentService</code>内部就是用了<code>HandlerThread</code>来实现的，不妨来看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</div><div class="line">    <span class="keyword">private</span> String mName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(looper);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            onHandleIntent((Intent)msg.obj);</div><div class="line">            stopSelf(msg.arg1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates an IntentService.  Invoked by your subclass's constructor.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> name Used to name the worker thread, important only for debugging.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets intent redelivery preferences.  Usually called from the constructor</div><div class="line">     * with your preferred semantics.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;If enabled is true,</div><div class="line">     * &#123;<span class="doctag">@link</span> #onStartCommand(Intent, int, int)&#125; will return</div><div class="line">     * &#123;<span class="doctag">@link</span> Service#START_REDELIVER_INTENT&#125;, so if this process dies before</div><div class="line">     * &#123;<span class="doctag">@link</span> #onHandleIntent(Intent)&#125; returns, the process will be restarted</div><div class="line">     * and the intent redelivered.  If multiple Intents have been sent, only</div><div class="line">     * the most recent one is guaranteed to be redelivered.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;If enabled is false (the default),</div><div class="line">     * &#123;<span class="doctag">@link</span> #onStartCommand(Intent, int, int)&#125; will return</div><div class="line">     * &#123;<span class="doctag">@link</span> Service#START_NOT_STICKY&#125;, and if the process dies, the Intent</div><div class="line">     * dies along with it.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">        mRedelivery = enabled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line">        <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line">        <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"></div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">        thread.start();</div><div class="line"></div><div class="line">        mServiceLooper = thread.getLooper();</div><div class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        Message msg = mServiceHandler.obtainMessage();</div><div class="line">        msg.arg1 = startId;</div><div class="line">        msg.obj = intent;</div><div class="line">        mServiceHandler.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * You should not override this method for your IntentService. Instead,</div><div class="line">     * override &#123;<span class="doctag">@link</span> #onHandleIntent&#125;, which the system calls when the IntentService</div><div class="line">     * receives a start request.</div><div class="line">     * <span class="doctag">@see</span> android.app.Service#onStartCommand</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        onStart(intent, startId);</div><div class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        mServiceLooper.quit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Unless you provide binding for your service, you don't need to implement this</div><div class="line">     * method, because the default implementation returns null.</div><div class="line">     * <span class="doctag">@see</span> android.app.Service#onBind</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This method is invoked on the worker thread with a request to process.</div><div class="line">     * Only one Intent is processed at a time, but the processing happens on a</div><div class="line">     * worker thread that runs independently from other application logic.</div><div class="line">     * So, if this code takes a long time, it will hold up other requests to</div><div class="line">     * the same IntentService, but it will not hold up anything else.</div><div class="line">     * When all requests have been handled, the IntentService stops itself,</div><div class="line">     * so you should not call &#123;<span class="doctag">@link</span> #stopSelf&#125;.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> intent The value passed to &#123;<span class="doctag">@link</span></div><div class="line">     *               android.content.Context#startService(Intent)&#125;.</div><div class="line">     *               This may be null if the service is being restarted after</div><div class="line">     *               its process has gone away; see</div><div class="line">     *               &#123;<span class="doctag">@link</span> android.app.Service#onStartCommand&#125;</div><div class="line">     *               for details.</div><div class="line">     */</div><div class="line">    <span class="meta">@WorkerThread</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到在<code>onCreate()</code>方法里创建了一个命名为<code>thread</code>的<code>HandlerThread</code>实例，同时也创建了一个<code>ServiceHandler</code>的实例，并将从<code>thread</code>里获取到的<code>looper</code>作为初始化参数传入，在<code>onStart()</code>方法中调用了<code>mServiceHandler.sendMessage(msg);</code>，再看<code>ServiceHandler</code>中的<code>handleMessage(Message msg)</code>方法中调用了<code>onHandleIntent((Intent)msg.obj);</code>，即我们要实现的抽象方法，该方法在子线程中执行。</p>
<p><code>HanderThread</code>的优点在于我们可以不用重复创建线程执行异步操作，缺点也很明显，就是它是队列的形式执行异步任务。</p>
]]></content>
    
    <summary type="html">
    
      对 HandlerThread 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://yoursite.com/2018/08/11/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/11/Java反射机制/</id>
    <published>2018-08-11T13:53:45.000Z</published>
    <updated>2019-10-12T11:27:12.055Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><blockquote>
<p>Reflection is a feature in the Java programming language. It allows an executing Java program to examine or “introspect” upon itself, and manipulate internal properties of the program. For example, it’s possible for a Java class to obtain the names of all its members and display them. — <a href="https://www.oracle.com/technetwork/articles/java/javareflection-1536171.html" target="_blank" rel="external">from oracle</a></p>
</blockquote>
<p>大致意思是反射是 Java 语言的特性之一，它允许一个运行中的 Java 程序去获取自身的信息并操作它们。</p>
<p>首先我们定义一个 Student 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">protected</span> String name;</div><div class="line">	<span class="keyword">public</span> String gender;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, String gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>获取 Class 对象有如下三种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class clsA = Class.forName(<span class="string">"com.djp.demo.Student"</span>);</div><div class="line">Class clsB = Student.class;</div><div class="line">Class clsC = <span class="keyword">new</span> Student().getClass();</div></pre></td></tr></table></figure></p>
<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethods</span><span class="params">(Class cls)</span> </span>&#123;</div><div class="line">	Method[] methods = cls.getDeclaredMethods();</div><div class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">		System.out.println(method.toString());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>getDeclaredMethods()</code>方法可以返回类或者接口的所有方法，包括 public, protected, defalut, and private，但无法获取到继承的方法。打印信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public java.lang.String com.djp.demo.Student.getName()</div><div class="line">public void com.djp.demo.Student.setName(java.lang.String)</div><div class="line">public int com.djp.demo.Student.getAge()</div><div class="line">public java.lang.String com.djp.demo.Student.getGender()</div><div class="line">public void com.djp.demo.Student.setGender(java.lang.String)</div><div class="line">public void com.djp.demo.Student.setAge(int)</div></pre></td></tr></table></figure></p>
<p>另一个<code>getMethods()</code>方法也可以获取到类和接口的所有方法，于上面方法不同的是调用这个方法只会返回定义为 public 的 Method 对象，包括继承的方法。</p>
<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>有两种方法可以创建实例，第一种是直接通过 class 对象的 newInstance 创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class clsA = Class.forName(<span class="string">"com.djp.demo.Student"</span>);</div><div class="line">clsA.newInstance();</div></pre></td></tr></table></figure></p>
<p>第二种通过构造器创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Constructor constructor = cls.getConstructor(<span class="keyword">int</span>.class, String.class, String.class);</div><div class="line">Student student = (Student) constructor.newInstance(<span class="number">18</span>, <span class="string">"lucien"</span>, <span class="string">"man"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="通过-name-调用方法"><a href="#通过-name-调用方法" class="headerlink" title="通过 name 调用方法"></a>通过 name 调用方法</h3><p>首先根据 name 获取到 Method 对象，然后调用 invoke 方法传入对应参数就可以调用方法了，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method method = cls.getMethod(<span class="string">"getAge"</span>);</div><div class="line">method.invoke(<span class="keyword">new</span> Student(<span class="number">22</span>,<span class="string">"lucien"</span>,  <span class="string">"man"</span>));</div></pre></td></tr></table></figure></p>
<h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><p>通过调用 <code>getDeclaredFields()</code> 或者 <code>getFields()</code>，方法区别和获取方法类似。</p>
]]></content>
    
    <summary type="html">
    
      对 Java 反射机制的简要总结。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags%C3%9F/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务学习笔记</title>
    <link href="http://yoursite.com/2018/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/08/09/数据库事务学习笔记/</id>
    <published>2018-08-09T13:17:28.000Z</published>
    <updated>2019-10-12T11:40:58.376Z</updated>
    
    <content type="html"><![CDATA[<p>数据库事务（简称事务）：是数据库管理系统（Database Managment System 简称 DBMS）执行过程中的一个逻辑单位，是由有限的数据库操作序列构成。</p>
<p>事务的特性：</p>
<ul>
<li>原子性：事务作为一个整体执行，包含在其中的数据库操作要么全部执行，要么不执行。</li>
<li>一致性：事务要确保数据库由一个一致性的状态变成另一个一致性的状态。</li>
<li>隔离性：允许多个事务并发进行，并且执行过程中一个事务不应受另外一个事务影响。</li>
<li>持久性：已经提交的事务对数据库的修改应该永远保存在数据库中。</li>
</ul>
<p>事务的四种隔离：</p>
<ul>
<li>读未提交（Read uncommitted）：允许“脏读”，即事务可以读到其它事务还未提交的修改。</li>
<li>读已提交（Read committed）：只能读取到已经提交的数据。</li>
<li>可重复读（Repeatable reads）：即在事务中的查询和开始是一致的。</li>
<li>可串形化（Serializable）：在基于锁机制并发控制的 DBMS 实现可串行化，要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在 SELECT 的查询中使用一个“WHERE”子句来描述一个范围时应该获得一个“范围锁”（range-locks）。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文主要是学习数据库事务时的笔记。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="database" scheme="http://yoursite.com/tags%C3%9F/database/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 排序算法之插入排序</title>
    <link href="http://yoursite.com/2018/06/09/%E9%87%8D%E6%8B%BE-DSA-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/06/09/重拾-DSA-排序算法之插入排序/</id>
    <published>2018-06-09T07:50:47.000Z</published>
    <updated>2018-06-09T08:22:27.075Z</updated>
    
    <content type="html"><![CDATA[<p>wikipedia:</p>
<blockquote>
<p>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
</blockquote>
<p>意思就是从输入的元素里每次取出一个插入到有序的列表中，直到取完所有的元素为止。<br><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt=""></p>
<p>以下是代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; array.length - <span class="number">1</span>; i++) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</div><div class="line">			<span class="keyword">if</span>(array[j - <span class="number">1</span>] &lt;= array[j])</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			<span class="keyword">int</span> temp = array[j - <span class="number">1</span>];</div><div class="line">			array[j - <span class="number">1</span>] = array[j];</div><div class="line">			array[j] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>算法的时间复杂度为 O(n^2)。</p>
]]></content>
    
    <summary type="html">
    
      关于插入排序的介绍和 Java 实现。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 排序算法之简单选择排序</title>
    <link href="http://yoursite.com/2018/05/31/%E9%87%8D%E6%8B%BE-DSA-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/31/重拾-DSA-排序算法之简单选择排序/</id>
    <published>2018-05-31T09:18:26.000Z</published>
    <updated>2018-05-31T09:41:01.129Z</updated>
    
    <content type="html"><![CDATA[<p>wikipedia:</p>
<blockquote>
<p>The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
</blockquote>
<p>概括就是将数列分为两部分，分别是排好序和未排好序部分，每次取未排序部分的最大值或者最小值，放到已排序部分的数列中。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt=""></p>
<p>以下是代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSelectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</div><div class="line">			<span class="keyword">if</span>(array[i] &gt; array[j]) &#123;</div><div class="line">				<span class="keyword">int</span> temp = array[i];</div><div class="line">				array[i] = array[j];</div><div class="line">				array[j] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该算法的时间复杂度为 O(n^2)。</p>
]]></content>
    
    <summary type="html">
    
      关于简答选择排序的简单介绍和 Java 实现。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 排序算法之快速排序</title>
    <link href="http://yoursite.com/2018/05/29/%E9%87%8D%E6%8B%BE-DSA-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/29/重拾-DSA-排序算法之快速排序/</id>
    <published>2018-05-29T08:23:15.000Z</published>
    <updated>2018-06-09T08:25:27.626Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序的主要运用的就是分治的思想。</p>
<blockquote>
<p>The steps are:</p>
</blockquote>
<p>1.Pick an element, called a pivot, from the array.</p>
<p>2.Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.</p>
<p>3.Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</p>
<p>上面是 wiki 中定义的步骤，其实就是先找一个 pivot，一般我们设定数组的第一个或者最后一个元素为 pivot，把数组中小于 pivot 的元素移到左边，大于 pivot 的元素移到右边，然后以同样的方式再对左右两边的子数组操作，最后就会得到一个有序数组。</p>
<p>sample:<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Quicksort-diagram.svg/200px-Quicksort-diagram.svg.png" alt=""> </p>
<p>以下是代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> l = low;</div><div class="line">	<span class="keyword">int</span> h = high;</div><div class="line">	<span class="keyword">if</span>(l &gt;= h)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="keyword">int</span> pivot = array[high];</div><div class="line">	<span class="keyword">while</span>(l &lt; h) &#123;</div><div class="line">		<span class="keyword">while</span>(array[l] &gt; pivot &amp;&amp; l &lt; h) &#123;</div><div class="line">			<span class="keyword">int</span> temp = array[h - <span class="number">1</span>];</div><div class="line">			array[h] = array[l];</div><div class="line">			array[l] = temp;</div><div class="line">			h--;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span>(array[l] &lt;= pivot &amp;&amp; l &lt; h) &#123;</div><div class="line">			l++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	array[l] = pivot;</div><div class="line">	sort(array, low, l - <span class="number">1</span>);</div><div class="line">	sort(array, l + <span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>快速排序的平均复杂度为 O(nlogn),最差情况下为 O(n^2)。</p>
]]></content>
    
    <summary type="html">
    
      关于快速排序的简单介绍和 Java 实现。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则</title>
    <link href="http://yoursite.com/2018/05/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2018/05/28/设计模式原则/</id>
    <published>2018-05-27T20:40:42.000Z</published>
    <updated>2018-05-27T20:57:12.181Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>单一职责原则(Single Responsibility Principle): 就一个类而言，应该只有一个引起它变化的原因。</li>
<li>开闭原则(Open-Closed Principle): 一个软件实体应当对扩展开放，对修改关闭。</li>
<li>里氏替换原则(Liskov Substitution Principle): 所有引用基类（父类）的地方必须能透明地使用其子类的对象。</li>
<li>依赖倒置原则(Dependency Inversion  Principle): 针对接口编程，而不是针对实现编程。</li>
<li>接口隔离原则(Interface  Segregation Principle): 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</li>
<li>迪米特法则(Law of  Demeter): 一个软件实体应当尽可能少地与其他实体发生相互作用。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;单一职责原则(Single Responsibility Principle): 就一个类而言，应该只有一个引起它变化的原因。&lt;/li&gt;
&lt;li&gt;开闭原则(Open-Closed Principle): 一个软件实体应当对扩展开放，对修改关闭。&lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags%C3%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 排序算法之冒泡排序</title>
    <link href="http://yoursite.com/2018/05/23/%E9%87%8D%E6%8B%BE-DSA-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/23/重拾-DSA-排序算法之冒泡排序/</id>
    <published>2018-05-23T10:36:06.000Z</published>
    <updated>2019-10-12T11:29:08.945Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于冒泡排序的概括：</p>
<blockquote>
<p>Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements “bubble” to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to insertion sort.[2] Bubble sort can be practical if the input is in mostly sorted order with some out-of-order elements nearly in position.</p>
</blockquote>
<p>简而言之呢就是相领元素的比较，下面还是来自 wikipedia 的一张图，很直观了：<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" alt=""> </p>
<p>不妨假设我们有这样一个数组<code>int list[] = {5, 1, 4, 2, 8};</code><br>那么冒泡排序的步骤就如下:</p>
<p>第一趟：<br>{<strong>5</strong>, <strong>1</strong>, 4, 2, 8} -&gt; {<strong>1</strong>, <strong>5</strong>, 4, 2, 8}, 5 &gt; 1, 交换位置;<br>{1, <strong>5</strong>, <strong>4</strong>, 2, 8} -&gt; {1, <strong>4</strong>, <strong>5</strong>, 2, 8}, 5 &gt; 4, 交换位置;<br>{1, 4, <strong>5</strong>, <strong>2</strong>, 8} -&gt; {1, 4, <strong>2</strong>, <strong>5</strong>, 8}, 5 &gt; 2, 交换位置;<br>{1, 4, 2, <strong>5</strong>, <strong>8</strong>} -&gt; {1, 4, 2, <strong>5</strong>, <strong>8</strong>}, 5 &lt; 8, 位置不变;<br>所以第一趟排序下来的数组顺序是 {1, 4, 2, 5, 8}，此时数组中最大的数 <strong>8</strong> 已经在末尾。</p>
<p>第二趟：<br>{<strong>1</strong>, <strong>4</strong>, 2, 5, 8} -&gt; {<strong>1</strong>, <strong>4</strong>, 2, 5, 8}, 1 &lt; 4, 位置不变;<br>{1, <strong>4</strong>, <strong>2</strong>, 5, 8} -&gt; {1, <strong>2</strong>, <strong>4</strong>, 5, 8}, 4 &gt; 2, 交换位置;<br>{1, 2, <strong>4</strong>, <strong>5</strong>, 8} -&gt; {1, 2, <strong>4</strong>, <strong>5</strong>, 8}, 4 &lt; 5, 位置不变;<br>第二趟排序下来数组中第二大的数已经在倒数第二的位置。</p>
<p>第三趟：<br>{<strong>1</strong>, <strong>2</strong>, 4, 5, 8} -&gt; {<strong>1</strong>, <strong>2</strong>, 4, 5, 8}, 1 &lt; 2, 位置不变;<br>{1, <strong>2</strong>, <strong>4</strong>, 5, 8} -&gt; {1, <strong>2</strong>, <strong>4</strong>, 5, 8}, 2 &lt; 4, 位置不变;</p>
<p>第四趟：<br>{<strong>1</strong>, <strong>2</strong>, 4, 5, 8} -&gt; {<strong>1</strong>, <strong>2</strong>, 4, 5, 8}, 1 &lt; 2, 位置不变;</p>
<p>以下是代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] list) &#123;</div><div class="line">		<span class="keyword">int</span> length = list.length;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</div><div class="line">				<span class="keyword">if</span>(list[j] &gt; list[j + <span class="number">1</span>]) &#123;</div><div class="line">					<span class="keyword">int</span> temp = list[j];</div><div class="line">					list[j] = list[j + <span class="number">1</span>];</div><div class="line">					list[j + <span class="number">1</span>] = temp;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> list;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>冒泡排序的效率并不高，时间复杂度为 O(n^2)；</p>
]]></content>
    
    <summary type="html">
    
      关于冒泡排序的简单介绍和 Java 实现。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Android抽象布局</title>
    <link href="http://yoursite.com/2018/05/20/Android%E6%8A%BD%E8%B1%A1%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/05/20/Android抽象布局/</id>
    <published>2018-05-20T10:03:24.000Z</published>
    <updated>2019-10-12T11:23:44.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-lt-include-gt-标签"><a href="#1-lt-include-gt-标签" class="headerlink" title="1.&lt;include /&gt; 标签"></a>1.<code>&lt;include /&gt;</code> 标签</h3><p><code>&lt;include /&gt;</code> 标签主要解决布局重用的问题，在我们大多数的 app 中的标题栏布局都是相似的，这个时候就可以用 <code>&lt;include /&gt;</code> 标签重用布局文件了。使用方法如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">	<span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">	<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">	<span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">	<span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/include_head"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="2-lt-merge-gt-标签"><a href="#2-lt-merge-gt-标签" class="headerlink" title="2.&lt;merge /&gt; 标签"></a>2.<code>&lt;merge /&gt;</code> 标签</h3><p><code>&lt;merge /&gt;</code> 标签的作用可以减少 UI 的层级，假如要在主布局 <code>LinearLayout</code> 中引入同样是 <code>LinearLayout</code> 的 <code>include</code> 布局，那么便可以将引入布局的最外层布局设置为 <code>&lt;merge /&gt;</code> 标签，这样系统将会自动忽略 <code>&lt;merge /&gt;</code>节点，从而达到减少布局层次的目的。比如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"hello"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"world"</span> /&gt;</div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="3-lt-ViewStub-gt-标签"><a href="#3-lt-ViewStub-gt-标签" class="headerlink" title="3.&lt;ViewStub /&gt; 标签"></a>3.<code>&lt;ViewStub /&gt;</code> 标签</h3><p><code>&lt;ViewStub /&gt;</code> 标签的作用就是延迟加载布局资源，从而达到加快 UI 初始化速度目的，适用场景如进度条，加载失败布局等一些一开始不需要加载的布局。如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> </span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.juhe.generaldemo.MainActivity"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">ViewStub</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/viewstub"</span></div><div class="line">        <span class="attr">android:layout</span>=<span class="string">"@layout/viewstub_layout"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>想要加载布局时：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ViewStub viewStub = (ViewStub) findViewById(R.id.viewstub);</div><div class="line">viewStub.inflate();</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      简单介绍 Android 中 &amp;lt;include /&amp;gt;、 &amp;lt;merge /&amp;gt; 和 &amp;lt;ViewStub /&amp;gt; 标签的使用。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 之树</title>
    <link href="http://yoursite.com/2017/08/19/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E6%A0%91/"/>
    <id>http://yoursite.com/2017/08/19/重拾-DSA-之树/</id>
    <published>2017-08-19T01:50:40.000Z</published>
    <updated>2018-12-23T04:33:30.678Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于树的定义：</p>
<blockquote>
<p><strong>树</strong>（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ul>
</blockquote>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；<br><strong>树的度</strong>：一棵树中最大的节点的度称为树的度；<br><strong>叶子结点</strong>：度为零的节点；<br><strong>分支节点</strong>：度不为零的节点；<br><strong>父节点</strong>：若一个节点含有字节点，则这个节点称为该字节点的父节点；<br><strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的字节点；<br><strong>兄弟节点</strong>：具有相同父节点的节点称为兄弟节点；<br><strong>节点的层次</strong>：从根开始定义，根为第一层，根的子节点为第2层，以此类推；<br><strong>树的高度或深度</strong>：树中节点的最大层次；<br><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；<br><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；<br><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙；<br><strong>森林</strong>：由 m（m &gt;= 0）棵互不相交的树的结合成为森林；<br><img src="http://wx2.sinaimg.cn/large/9302210cly1fyghx5gzzej207t07j74a.jpg" alt=""><br>如上图 B 节点的度为 2，C 的度为 1，整棵树的高度为 2。这棵树的叶子结点有 D、G、F，剩下的是分支节点。A 是 B 的父节点，A 是 C 的父节点，B 和 C 是兄弟节点。A 节点的层次为 1， B 节点的层次为 2，D 节点的层次为 3，树的高度为 3， D、E、F互为堂兄弟。</p>
<h3 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h3><p>树的种类可以分为两种，分别是<strong>无序树</strong>和<strong>有序树</strong>。无序树树中任意节点的子节点之间没有顺序关系，无序树也可以称为自由树；有序树表示树中任意节点的子节点之间有顺序关系。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是属于有序树中的一种，每个节点最多含有两个字树的树称为二叉树。</p>
<p>三种遍历方式（递归方式）：</p>
<p>先序遍历： 根节点-左节点-右节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</div><div class="line">		System.out.print(node.data + <span class="string">"--&gt;"</span>);</div><div class="line">		preOrder(node.left);</div><div class="line">		preOrder(node.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>中序遍历： 左节点-根节点-右节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</div><div class="line">		inOrder(node.left);</div><div class="line">		System.out.print(node.data + <span class="string">"--&gt;"</span>);</div><div class="line">		inOrder(node.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>后续遍历： 左节点-右节点-根节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</div><div class="line">		postOrder(node.left);</div><div class="line">		postOrder(node.right);</div><div class="line">		System.out.print(node.data + <span class="string">"--&gt;"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/lucien623/DSA_Review/blob/master/BinaryTree.java" target="_blank" rel="external">Source Code</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是 wikipedia 对于树的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n&amp;gt;0）个有限节点
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 之队列</title>
    <link href="http://yoursite.com/2017/08/12/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/08/12/重拾-DSA-之队列/</id>
    <published>2017-08-12T08:40:19.000Z</published>
    <updated>2019-10-12T11:40:43.472Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于队列的定义：</p>
<blockquote>
<p><strong>队列</strong>又称为伫列（queue），是先进先出（FIFO, First In First Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</p>
</blockquote>
<p>队列和栈十分相似，不同点在于栈是 Last In First Out，而队列是 First In First Out。</p>
<p>这里使用 LinkedList 存储数据。</p>
<ul>
<li>添加一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">	mList.addLast(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>移除元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(!mList.isEmpty()) &#123;</div><div class="line">		mList.removeFirst();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取队列元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">getHead</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> mList.getFirst();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/lucien623/DSA_Review/blob/master/Queue.java" target="_blank" rel="external">Source Code</a></p>
]]></content>
    
    <summary type="html">
    
      本文主要介绍了队列的基本知识。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 之栈</title>
    <link href="http://yoursite.com/2017/08/12/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E6%A0%88/"/>
    <id>http://yoursite.com/2017/08/12/重拾-DSA-之栈/</id>
    <published>2017-08-12T08:15:03.000Z</published>
    <updated>2017-08-12T08:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于栈的定义：</p>
<blockquote>
<p><strong>堆栈</strong> （英语：stack），也可直接称栈（港澳台作堆叠），在计算机科学中，是一种特殊的串列形式的数据结构，它的特殊之处在于只能允许在链接串列或阵列的一端（称为堆叠顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外栈也可以用一维数组或连结串列的形式来完成。<br>由于堆叠数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。</p>
</blockquote>
<p>简单示意图：<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/391px-Data_stack.svg.png" alt=""></p>
<p>这里使用 LinkedList 存储数据。</p>
<ul>
<li>入栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">	mList.addFirst(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(!mList.isEmpty()) &#123;</div><div class="line">		mList.removeFirst();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取栈顶元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getPop</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> mList.getFirst();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/lucien623/DSA_Review/blob/master/Stack.java" target="_blank" rel="external">Source Code</a></p>
]]></content>
    
    <summary type="html">
    
      本文主要介绍了栈的基本知识。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重拾  DSA 之链表</title>
    <link href="http://yoursite.com/2017/08/11/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/08/11/重拾-DSA-之链表/</id>
    <published>2017-08-11T07:40:59.000Z</published>
    <updated>2019-10-12T11:07:58.632Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于链表的定义：</p>
<blockquote>
<p><strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到   O(1) 的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要 O(n) 的时间，而顺序表相应的时间复杂度分别是 O(logn) 和 O(1)。</p>
</blockquote>
<ul>
<li>添加<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object data)</span> </span>&#123;</div><div class="line">	<span class="comment">//如果头节点为空，则创建一个新节点，并将其设置为头节点以及当前节点。</span></div><div class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</div><div class="line">		head = <span class="keyword">new</span> Node(data);</div><div class="line">		current = head;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		current.next = <span class="keyword">new</span> Node(data);</div><div class="line">		current = current.next;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>插入<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Object data)</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">if</span>(index == <span class="number">0</span>) &#123;</div><div class="line">		head = <span class="keyword">new</span> Node(data);</div><div class="line">		head.next = current;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	Node preNode = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>((<span class="keyword">int</span>)current.data == index) &#123;</div><div class="line">			Node node = <span class="keyword">new</span> Node(data);</div><div class="line">			preNode.next = node;</div><div class="line">			node.next = current;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		preNode = current;</div><div class="line">		current = current.next;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>删除<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">	Node preNode = head;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(pos == index) &#123;</div><div class="line">			<span class="keyword">if</span>(pos == <span class="number">0</span>)</div><div class="line">				head = current.next;</div><div class="line">			<span class="comment">//判断当前节点是否还有下一个节点，有则将前一个节点的next指向下一个节点，</span></div><div class="line">			<span class="comment">//无则将前一个节点的next指向设置为null</span></div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">if</span>(current.next != <span class="keyword">null</span>) &#123;</div><div class="line">					preNode.next = current.next;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					preNode.next = <span class="keyword">null</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		preNode = current;</div><div class="line">		current = current.next;</div><div class="line">		pos++;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>查找<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(index == pos) &#123;</div><div class="line">			<span class="keyword">return</span> current;</div><div class="line">		&#125;</div><div class="line">		current = current.next;</div><div class="line">		pos++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>获取链表中节点的个数<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLinkListLength</span><span class="params">()</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		length++;</div><div class="line">		current = current.next;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>链表反转<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseLinkList</span><span class="params">()</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		Node preHead = reverseHead;</div><div class="line">		reverseHead = current;</div><div class="line">		current = current.next;</div><div class="line">		<span class="keyword">if</span>(preHead != <span class="keyword">null</span>) &#123;</div><div class="line">			reverseHead.next = preHead;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			reverseHead.next = <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>链表反转（递归方式）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">reverseLinkListRec</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">return</span> head;</div><div class="line">	Node newHead = reverseLinkListRec(head.next);</div><div class="line">	head.next.next = head;</div><div class="line">	head.next = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">return</span> newHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>获取倒数第 index 节点（先让当前节点移动到第 index 个节点，再创建一个节点 start 指向头节点，当前节点和 start 节点同时移动，当当前节点移动到最后一个节点时，start 指向的便是倒数第 index 节点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">getReciprocalNode</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(index == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	current = head;</div><div class="line">	Node start = head;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		index--;</div><div class="line">		<span class="keyword">if</span>(index == <span class="number">0</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		current = current.next;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 长度大于链表长度</span></div><div class="line">	<span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(current.next != <span class="keyword">null</span>) &#123;</div><div class="line">		current = current.next;</div><div class="line">		start = start.next;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> start;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>获取链表的中间节点(初始化两个节点都指向头节点，一个节点每次移动一个节点，另一个每次移动两个节点，当第二个节点移动到链表末尾时，第一个节点指向的节点即是链表的中间节点)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">getMiddleNode</span><span class="params">()</span> </span>&#123;</div><div class="line">	Node oneStepNode = head;</div><div class="line">	Node twoStepNode = head;</div><div class="line">	<span class="comment">//加入小于三个节点则返回第一个节点作为中间节点</span></div><div class="line">	<span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> current;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(twoStepNode.next != <span class="keyword">null</span> &amp;&amp; twoStepNode.next.next != <span class="keyword">null</span>) &#123;</div><div class="line">		twoStepNode = twoStepNode.next.next;</div><div class="line">		oneStepNode = oneStepNode.next;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> oneStepNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://github.com/lucien623/DSA_Review/blob/master/LinkList.java" target="_blank" rel="external">Source Code</a></p>
]]></content>
    
    <summary type="html">
    
      本文主要介绍了链表的一些操作。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Android事件分发</title>
    <link href="http://yoursite.com/2017/07/11/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>http://yoursite.com/2017/07/11/android事件分发/</id>
    <published>2017-07-11T09:06:00.000Z</published>
    <updated>2018-12-23T04:33:31.575Z</updated>
    
    <content type="html"><![CDATA[<p>Android 中和事件分发相关的主要有三个方法，分别是 dispatchTouchEvent(…)、onInterceptTouchEvent(…) 和 onTouchEvent(…)，主要作用是分发事件、是否拦截事件以及处理事件，这些方法的返回值决定了 Touch 事件的传递方向，方法的包涵情况具体如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">dispatchTouchEvent(…)</th>
<th style="text-align:center">onInterceptTouchEvent(…)</th>
<th style="text-align:center">onTouchEvent(…)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Activity</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td>ViewGroup</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td>view</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
</tbody>
</table>
<p>以下为事件分发流程图（针对于 ACTION_DOWN 事件，可点击查看大图）</p>
<!-- touchevent.png -->
<p><img src="http://wx4.sinaimg.cn/large/9302210cly1fygi1siu3qj21ex0t876w.jpg" alt=""></p>
<p>如图所示的事件传递流向已十分清晰，demo 也十分易写，只需自行重写这些方法，打印日志便可验证。</p>
<p>对于 ACTION_MOVE 和 ACTION_UP 事件的传递则略有不同，它们的传递和 ACTION_DOWN 事件传递的终点相关，以下举例。</p>
<h4 id="1）在-View-的-onTouchEvent-消费事件，即-return-true。"><a href="#1）在-View-的-onTouchEvent-消费事件，即-return-true。" class="headerlink" title="1）在 View 的 onTouchEvent 消费事件，即 return true。"></a>1）在 View 的 onTouchEvent 消费事件，即 return true。</h4><p>日志：</p>
<!-- touchevent_2_log -->
<p><img src="http://wx3.sinaimg.cn/large/9302210cly1fygi14xf2mj21ww08in3n.jpg" alt=""></p>
<p>事件传递的流向图：</p>
<!-- touchevent_2.png -->
<p><img src="http://wx1.sinaimg.cn/large/9302210cly1fygi18l5huj21gd0u0gt7.jpg" alt=""></p>
<h4 id="2）在-ViewGroup-的-onTouchEvent-…-消费事件，即-return-true。"><a href="#2）在-ViewGroup-的-onTouchEvent-…-消费事件，即-return-true。" class="headerlink" title="2）在 ViewGroup 的 onTouchEvent(…) 消费事件，即 return true。"></a>2）在 ViewGroup 的 onTouchEvent(…) 消费事件，即 return true。</h4><p>日志：</p>
<!-- touchevent_1_log -->
<p><img src="http://wx4.sinaimg.cn/large/9302210cly1fygi0wgpg3j21ww07mq8v.jpg" alt=""></p>
<p>事件传递的流向图：</p>
<!-- touchevent_1 -->
<p><img src="http://wx2.sinaimg.cn/large/9302210cly1fygi10hcufj21gb0u0dn6.jpg" alt=""></p>
<h4 id="3）在-ViewGroup-的-dispatchTouchEvent-…-方法中-return-false。"><a href="#3）在-ViewGroup-的-dispatchTouchEvent-…-方法中-return-false。" class="headerlink" title="3）在 ViewGroup 的 dispatchTouchEvent(…) 方法中 return false。"></a>3）在 ViewGroup 的 dispatchTouchEvent(…) 方法中 return false。</h4><p>日志：</p>
<!-- touchevent_3_log -->
<p><img src="http://wx4.sinaimg.cn/large/9302210cly1fygi1c1kczj21ww044jup.jpg" alt=""></p>
<p>事件传递流向图：</p>
<!-- touchevent_3 -->
<p><img src="http://wx1.sinaimg.cn/large/9302210cly1fygi1oxebij21gh0u0tfs.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 中和事件分发相关的主要有三个方法，分别是 dispatchTouchEvent(…)、onInterceptTouchEvent(…) 和 onTouchEvent(…)，主要作用是分发事件、是否拦截事件以及处理事件，这些方法的返回值决定了 Touch 事件
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity生命周期</title>
    <link href="http://yoursite.com/2017/07/10/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2017/07/10/Activity生命周期/</id>
    <published>2017-07-10T03:37:39.000Z</published>
    <updated>2017-08-04T05:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Activity 是 Android 四大组件之一，它主要给用户提供了一个交互页面，用户通过它与app进行交互，以执行各种操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上（将 Activity 的 theme 设置为 Dialog）。Activity 生命周期中主要的七个回调方法介绍如下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>onCreate()</td>
<td>Activity 创建的时候调用,可以在方法里做一些初始化的操作，比如初始化试图，获取从上一个页面传递过来的数据，此时处于不可见状态。</td>
</tr>
<tr>
<td>onRestart()</td>
<td>在 Activity 已停止并即将再次启动前调用。</td>
</tr>
<tr>
<td>onStart()</td>
<td>Activity 处于可见状态，但不能操作，因为并未获取到焦点。</td>
</tr>
<tr>
<td>onResume()</td>
<td>Activity 处于可见状态，并且能够获取到焦点，在 Activity 恢复时可以在此方法中刷新数据。</td>
</tr>
<tr>
<td>onPause()</td>
<td>当系统即将开始继续另一个 Activity 时调用。当此方法执行完才会启动下一个 Activity，此方法中可以做一些停止动画，释放一些资源的操作，但不适合一些比较耗时的操作，因为这样会导致跳转的时候卡顿。</td>
</tr>
<tr>
<td>onStop()</td>
<td>在 Activity 对用户不再可见时调用。如果 Activity 恢复交互，那么接下来会调用 onRestart() 方法，如果 Activity 销毁，那么将会调用 onDestory() 方法。</td>
</tr>
<tr>
<td>onDestory()</td>
<td>在 Activity 被销毁前调用。</td>
</tr>
</tbody>
</table>
<p><img src="https://developer.android.com/images/activity_lifecycle.png" alt="activity-life"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Activity 是 Android 四大组件之一，它主要给用户提供了一个交互页面，用户通过它与app进行交互，以执行各种操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上（将 Activity 的 
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
</feed>
