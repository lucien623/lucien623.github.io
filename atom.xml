<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucien</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2023-01-01T14:38:20.742Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lucien</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>斯多葛主义</title>
    <link href="http://yoursite.com/2023/01/01/%E6%96%AF%E5%A4%9A%E8%91%9B%E4%B8%BB%E4%B9%89/"/>
    <id>http://yoursite.com/2023/01/01/斯多葛主义/</id>
    <published>2023-01-01T14:33:48.000Z</published>
    <updated>2023-01-01T14:38:20.742Z</updated>
    
    <content type="html"><![CDATA[<h3 id="斯多葛主义的心理技巧"><a href="#斯多葛主义的心理技巧" class="headerlink" title="斯多葛主义的心理技巧"></a>斯多葛主义的心理技巧</h3><ul>
<li><p>消极想象</p>
<p>  消极想象的三个好处：一是当我们做消极想象的时候，会尽力去避免消极想象的事情发生；二是当消极想象中的事情真的发生时，通过这种方式可以减轻由此带来的痛苦；三是进行消极想象可以阻止我们享乐适应，因为人们通常在满足某种欲望的时候，往往持续的幸福不会很久就会乏味，消极想象可以防止这种幸福感的消失。</p>
</li>
<li><p>控制三分法</p>
<p>  控制三分法将事物分成三种类别。第一种是我们完全能够控制的事物，比如我们的目标和价值观；第二种是我们一点也不能控制的事物，比如明天是否会出现太阳；第三种则是我们能够控制一些但却有不能完全控制的事物，比如能否赢下一场网球赛。控制三分法让我们应当关注第一种事物，不关注第二种事物，在面对第三种我们能够控制一些但又无法完全控制的事物时，我们应当将外在目标内在化，比如应该将「使他爱我」这个目标转换成让自己值得被爱；面对老板，尽自己的最大努力做好工作，不论随后老板对我有什么反应。</p>
</li>
<li><p>宿命论</p>
<p>  我们应当针对过去和现在采用宿命论，「接受命运的安排」，拒绝考虑自身的情况如何可能会变得更好（对过去的懊悔）。</p>
</li>
<li><p>自我否定</p>
<p>  斯多葛主义不仅要求我们进行消极想象，还建议我们应时不常地给自己制造机会去经历本来可以避免的不舒适。对于这种行为的好处可以有三点：一是可以使得我们变得更加坚韧，以便抵御将来可能降临的命运；二是经历微小不适可以使自己变得有信心，认为自己同样可以承受更严重的不信；三是可以帮助我们享受我们已经拥有的东西。</p>
</li>
<li><p>沉思：监督自我践行斯多葛主义</p>
<p>  我们应当定期对日常生活中的事情进行思考，根据斯多葛主义的原则，应该如何处理发生的事情。</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;斯多葛主义的心理技巧&quot;&gt;&lt;a href=&quot;#斯多葛主义的心理技巧&quot; class=&quot;headerlink&quot; title=&quot;斯多葛主义的心理技巧&quot;&gt;&lt;/a&gt;斯多葛主义的心理技巧&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;消极想象&lt;/p&gt;
&lt;p&gt;  消极想象的三个好处：一是当我们
    
    </summary>
    
      <category term="阅读" scheme="http://yoursite.com/categories/%E9%98%85%E8%AF%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>记关于Fragment-java.lang.NoSuchMethodException的一个报错</title>
    <link href="http://yoursite.com/2022/02/15/%E8%AE%B0%E5%85%B3%E4%BA%8EFragment-java-lang-NoSuchMethodException%E7%9A%84%E4%B8%80%E4%B8%AA%E6%8A%A5%E9%94%99/"/>
    <id>http://yoursite.com/2022/02/15/记关于Fragment-java-lang-NoSuchMethodException的一个报错/</id>
    <published>2022-02-15T05:55:48.000Z</published>
    <updated>2022-02-15T06:34:36.465Z</updated>
    
    <content type="html"><![CDATA[<p>春节回来之后瞄了眼 bugly，发现了一个发生频次高影响用户广的 bug:</p>
<p><code>java.lang.RuntimeException:Unable to start activity ComponentInfo{.ui.activity.HomeActivity}: androidx.fragment.app.Fragment$InstantiationException: Unable to instantiate fragment .ui.fragment.q: could not find Fragment constructor</code></p>
<p>搜索了问题之后发现原因很简单，同事在创建的<code>Fragment</code>的时候用了带参数的构造方法，而没有添加无参构造，从而导致了这个 runtime exception，来看一下官方文档的解释：</p>
<p><code>All subclasses of Fragment must include a public no-argument constructor. The framework will often re-instantiate a fragment class when needed, in particular during state restore, and needs to be able to find this constructor to instantiate it. If the no-argument constructor is not available, a runtime exception will occur in some cases during state restore</code></p>
<p>从这段说明中可以看出所有的<code>Fragment</code>子类都必须包含无参的构造方法，系统在根据需要重新实例化<code>Fragment</code>子类时会默认去调用无参构造方法，如果没有找到这个无参方法，则会导致运行时错误。</p>
]]></content>
    
    <summary type="html">
    
      rt.
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>2021 年喜欢的一些东西</title>
    <link href="http://yoursite.com/2021/12/31/2021-%E5%B9%B4%E5%96%9C%E6%AC%A2%E7%9A%84%E4%B8%80%E4%BA%9B%E4%B8%9C%E8%A5%BF/"/>
    <id>http://yoursite.com/2021/12/31/2021-年喜欢的一些东西/</id>
    <published>2021-12-31T13:22:08.000Z</published>
    <updated>2022-02-08T10:01:54.731Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>喜欢的电子产品：</strong></p>
<p>  <code>AirPods Pro</code>。最初我计划买这耳机是因为用有线耳机的同时没法给手机充电，但当我入手之后发现降噪功能实在是太强大，戴上耳机之后世界瞬间清净了，减少了许多外界的打扰，后悔没有早点买，要说耳机的缺点么就是续航稍微有点短，至于音质当然和大法是没法比的，但也还能听。</p>
<p>  <code>KeychronK2</code>。非常棒的键盘，完美适配 mac，我买的是红轴，键盘敲击的声音不大，适合办公室，怎么说呢，用它来敲代码会有种停不下来的感觉，生产力加成。</p>
<p>  <strong>喜欢的运动：</strong></p>
<p>  <code>羽毛球</code>。开始打羽毛球是 6 月份的时候，契机是公司旁边开了一个羽毛球馆，因为之前一年的身体一直比较差没怎么运动，所以下决心报了一个羽毛球培训班学习，强身健体。喜欢羽毛球不仅仅是因为这项运动本身具有很多乐趣，同时因为从开始打羽毛球到现在的这半年里认识了好多好多新朋友，一起打球，一起玩耍，特别开心。</p>
<p>  <strong>喜欢的电影：</strong></p>
<p>  <code>阿黛尔的生活</code>。性与爱，太美了。</p>
<p>  <strong>喜欢的播客：</strong></p>
<p>  <code>谐星聊天会</code>。每周三都期盼着它更新，下班路上听经常走着走着就笑出来了，感谢插话师，感谢天花板，我的快乐源泉。</p>
<p>  <strong>喜欢的歌：</strong><br>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1483980586&auto=0&height=66"></iframe></p>
<p>  <code>与我常在</code>这个 2013 年的 Live 版本绝了。<br>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=28160884&auto=0&height=66"></iframe></p>
<p>  在我失落的时候这首歌总能给我力量与希望。<br>  <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1399050282&auto=0&height=66"></iframe></p>
]]></content>
    
    <summary type="html">
    
      关于 2021 年里喜欢的一些东西。
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Android 存储 API</title>
    <link href="http://yoursite.com/2021/12/14/Android-%E5%AD%98%E5%82%A8-API/"/>
    <id>http://yoursite.com/2021/12/14/Android-存储-API/</id>
    <published>2021-12-14T11:56:02.000Z</published>
    <updated>2021-12-14T12:23:47.426Z</updated>
    
    <content type="html"><![CDATA[<h3 id="internal-storage-对应的存储目录"><a href="#internal-storage-对应的存储目录" class="headerlink" title="internal storage 对应的存储目录"></a>internal storage 对应的存储目录</h3><p>getCacheDir(): <code>/data/data/&lt;application package&gt;/cache</code></p>
<p>getFilesDir(): <code>/data/data/&lt;application package&gt;/files</code></p>
<h3 id="external-storage-对应的存储目录"><a href="#external-storage-对应的存储目录" class="headerlink" title="external storage 对应的存储目录"></a>external storage 对应的存储目录</h3><p>getExternalFilesDir(): <code>/sdcard/Android/data/&lt;application package&gt;/files</code></p>
<p>getExternalCacheDir() : <code>/sdcard/Android/data/&lt;application package&gt;/cache</code></p>
<p>一般来说手机外部存储的空间比较大，所以如果需要保存比较大的文件时，应当存储在外部存储中。internal storage 和 external storage 在 app 被删除后相应的文件都会被删除。</p>
<p>如果需要存储不跟随 app 删除的文件，可以通过获取外部存储路径的方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File sdCardFile = Environment.getExternalStorageDirectory();</div><div class="line">File sdPic = <span class="keyword">new</span> File(sdCardFile, <span class="string">"Pictures"</span>);</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">File sdDoc = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOCUMENTS);</div></pre></td></tr></table></figure>
<p>前一种方式自己指定目录，后一种根据系统提供的参数获取目录。</p>
<p>在使用外部存储之前最好先加一个是否存在外部存储的判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Environment.isExternalStorageEmulated() 判断设备的外存是否是用内存模拟</span></div><div class="line">Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) || !Environment.isExternalStorageEmulated()</div></pre></td></tr></table></figure>
<p>更多关于存储的开发指南可以去 <a href="https://developer.android.com/training/data-storage?hl=zh-cn" target="_blank" rel="external">developer</a> 网站参考。</p>
]]></content>
    
    <summary type="html">
    
      关于 Android 存储 API 的简单笔记。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>关于PendingIntent数据重复问题</title>
    <link href="http://yoursite.com/2020/11/12/%E5%85%B3%E4%BA%8EPendingIntent%E6%95%B0%E6%8D%AE%E9%87%8D%E5%A4%8D%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/11/12/关于PendingIntent数据重复问题/</id>
    <published>2020-11-12T08:26:54.000Z</published>
    <updated>2020-11-12T08:58:36.247Z</updated>
    
    <content type="html"><![CDATA[<p>之前在测试推送的过程中发现了一个很奇怪的问题，就是当收到多条推送时，点击推送获取的到的数据都是第一条推送的，经过查找之后，发现了该问题的原因。接下来一段就是来自官网的描述</p>
<blockquote>
<p>A PendingIntent itself is simply a reference to a token maintained by the system describing the original data used to retrieve it. This means that, even if its owning application’s process is killed, the PendingIntent itself will remain usable from other processes that have been given it. If the creating application later re-retrieves the same kind of PendingIntent (same operation, same Intent action, data, categories, and components, and same flags), it will receive a PendingIntent representing the same token if that is still valid, and can thus call cancel() to remove it.<br>Because of this behavior, it is important to know when two Intents are considered to be the same for purposes of retrieving a PendingIntent. <strong>A common mistake people make is to create multiple PendingIntent objects with Intents that only vary in their “extra” contents, expecting to get a different PendingIntent each time.</strong> This does not happen. The parts of the Intent that are used for matching are the same ones defined by Intent#filterEquals(Intent). If you use two Intent objects that are equivalent as per Intent#filterEquals(Intent), then you will get the same PendingIntent for both of them.</p>
</blockquote>
<p>加粗部分的意思是说，如果<code>PendingIntent</code>只有在<code>Intent</code>中的<code>extra</code>不同的话，那么<code>PendingIntent</code>只会拿到相同的，即第一次的那个，所以问题就出现在这里，官方给了两种这个情况的解决方案</p>
<blockquote>
<p>If you truly need multiple distinct PendingIntent objects active at the same time (such as to use as two notifications that are both shown at the same time), then you will need to ensure there is something that is different about them to associate them with different PendingIntents. This may be any of the Intent attributes considered by Intent#filterEquals(Intent), or different request code integers supplied to getActivity(Context, int, Intent, int), getActivities(Context, int, Intent[], int), getBroadcast(Context, int, Intent, int), or getService(Context, int, Intent, int).<br>If you only need one PendingIntent active at a time for any of the Intents you will use, then you can alternatively use the flags FLAG_CANCEL_CURRENT or FLAG_UPDATE_CURRENT to either cancel or modify whatever current PendingIntent is associated with the Intent you are supplying.</p>
</blockquote>
<p>第一种方式就是给<code>Intent</code>设置不同的<code>filter</code>或者<code>request code</code>；第二种方式是如果不需要多个<code>PendingIntent</code>，那么可以在<code>flags</code>参数中传入<code>FLAG_CANCEL_CURRENT</code>或者<code>FLAG_UPDATE_CURRENT</code>将<code>PendingIntent</code>更新为最新的那个。因为我这边的情形是需要保留所有的不同的<code>PendingIntent</code>，所以采用了第一种方式，问题解决。</p>
]]></content>
    
    <summary type="html">
    
      关于推送过程中遇到 PendingIntent 数据重复问题的解决。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>Flutter 更新失败问题</title>
    <link href="http://yoursite.com/2020/05/26/Flutter-%E6%9B%B4%E6%96%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/05/26/Flutter-更新失败问题/</id>
    <published>2020-05-26T01:35:24.000Z</published>
    <updated>2020-05-26T02:08:43.326Z</updated>
    
    <content type="html"><![CDATA[<p>今天在执行<code>flutter upgrade</code>更新<code>flutter</code>时发现了一个更新失败问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Failed to retrieve the Dart SDK from: https://storage.googleapis.com/flutter_infra/flutter/6bc433c6b6b5b98dcf4cc11aff31cdee90849f32/dart-sdk-darwin-x64.zip</div></pre></td></tr></table></figure></p>
<p>发生这个问题的主要原因就是这个地址被墙了，官方也给出了<a href="https://flutter.dev/community/china" target="_blank" rel="external">解决方案</a>，就是给更新地址设置 mirror site，具体的方法就是在 Bash shell 中做如下设置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</div><div class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</div><div class="line">git clone -b dev https://github.com/flutter/flutter.git</div><div class="line">export PATH=&quot;$PWD/flutter/bin:$PATH&quot;</div><div class="line">cd ./flutter</div><div class="line">flutter doctor</div></pre></td></tr></table></figure></p>
<p>除了这个 mirror site 之外，还可以用 Shanghai Jiaotong University Linux User Group 的 mirror site：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FLUTTER_STORAGE_BASE_URL: https:<span class="comment">//mirrors.sjtug.sjtu.edu.cn/</span></div><div class="line">PUB_HOSTED_URL: https:<span class="comment">//dart-pub.mirrors.sjtug.sjtu.edu.cn/</span></div></pre></td></tr></table></figure></p>
<p>设置好之后就可以发会呆等待其 download 完成了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天在执行&lt;code&gt;flutter upgrade&lt;/code&gt;更新&lt;code&gt;flutter&lt;/code&gt;时发现了一个更新失败问题：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Flutter" scheme="http://yoursite.com/tags%C3%9F/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>mac中修改host的方法</title>
    <link href="http://yoursite.com/2019/12/11/mac%E4%B8%AD%E4%BF%AE%E6%94%B9host%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/12/11/mac中修改host的方法/</id>
    <published>2019-12-11T01:22:16.000Z</published>
    <updated>2019-12-11T01:39:01.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>输入命令<code>sudo vi /etc/hosts</code></p>
<h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>输入 pc 的密码</p>
<h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>按<code>i</code>键进入编辑模式，修改 host</p>
<h3 id="Step-4"><a href="#Step-4" class="headerlink" title="Step 4"></a>Step 4</h3><p>编辑完成后，按<code>esc</code>键退出编辑模式</p>
<h3 id="Step-5"><a href="#Step-5" class="headerlink" title="Step 5"></a>Step 5</h3><p>同时按<code>shift</code>和<code>:</code>键，并输入<code>wq!</code>，按回车键即编辑完成</p>
]]></content>
    
    <summary type="html">
    
      对 mac 中如何修改 host 的简要介绍
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>重拾 DSA 之二叉搜索树</title>
    <link href="http://yoursite.com/2019/10/26/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://yoursite.com/2019/10/26/重拾-DSA-之二叉搜索树/</id>
    <published>2019-10-26T05:49:48.000Z</published>
    <updated>2019-10-27T01:46:11.070Z</updated>
    
    <content type="html"><![CDATA[<p>二叉搜索树即 Binary Search Tree，也可以称为二叉查找树或者有序二叉树。它可以是空树或者是具有以下性质的二叉树（from wiki）：</p>
<blockquote>
<p>1.若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；<br>2.若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；<br>3.任意节点的左、右子树也分别为二叉查找树；<br>4.没有键值相等的节点。</p>
</blockquote>
<p>首先定义节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</div><div class="line">	TreeNode left,right;</div><div class="line">	<span class="keyword">int</span> value, num = <span class="number">1</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.value = value;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>插入节点，如果根节点为空则直接插入，否则与当前节点的值判断，如果大于当前节点，则和左子树中的节点判断，反之则和右子树中的节点做判断，直到比较到叶子节点最终确定插入位置，相等的特殊情况则将当前节点的 num 加 1，结束插入节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insertNode</span><span class="params">(TreeNode node)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</div><div class="line">		root = node;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	TreeNode temp = root;</div><div class="line">	<span class="keyword">for</span>(;;) &#123;</div><div class="line">		<span class="keyword">if</span>(node.value &gt; temp.value) &#123;</div><div class="line">			<span class="keyword">if</span>(temp.right != <span class="keyword">null</span>)</div><div class="line">				temp = temp.right;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				temp.right = node;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (node.value &lt; temp.value) &#123;</div><div class="line">			<span class="keyword">if</span>(temp.left != <span class="keyword">null</span>)</div><div class="line">				temp = temp.left;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				temp.left = node;</div><div class="line">				<span class="keyword">return</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			temp.num++;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>删除节点的逻辑分三种情况，如果待删除的节点是叶子节点，那么可以直接删除；如果待删除的节点只有左子树或者右子树，那么可以重接左子树或右子树，即把待删除节点的左节点或者右节点直接替代；如果待删除节点既有左子树又有右子树，那么把左子树中的最小值替代待删除节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">deleteNode</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(root == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	TreeNode parent;</div><div class="line">	TreeNode current = parent = root;</div><div class="line">	<span class="keyword">for</span>(;;)&#123;</div><div class="line">		<span class="keyword">if</span>(current.value == value)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		parent = current;</div><div class="line">		<span class="keyword">if</span>(current.value &lt; value)</div><div class="line">			current = current.right;</div><div class="line">		<span class="keyword">else</span> </div><div class="line">			current = current.left;</div><div class="line">		<span class="keyword">if</span>(current == <span class="keyword">null</span>)</div><div class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//叶子节点，直接删除</span></div><div class="line">	<span class="keyword">if</span>(current.left == <span class="keyword">null</span> &amp;&amp; current.right == <span class="keyword">null</span>) &#123;</div><div class="line">		 actualDelete(parent, current, <span class="keyword">null</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//左子树为空,重接右子树</span></div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current.left == <span class="keyword">null</span>)&#123;</div><div class="line">		actualDelete(parent, current, current.right);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//右子树为空,重接左子树</span></div><div class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(current.right == <span class="keyword">null</span>)&#123;</div><div class="line">		actualDelete(parent, current, current.left);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//左子树和右子树都不为空，那么将右子树中的最小节点替代被删除的节点</span></div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		TreeNode temp = current.left;</div><div class="line">		TreeNode tempParent = current;</div><div class="line">		<span class="keyword">while</span>(temp.left != <span class="keyword">null</span>) &#123;</div><div class="line">			tempParent = temp;</div><div class="line">			temp = temp.left;</div><div class="line">		&#125;</div><div class="line">		actualDelete(parent, current, temp);</div><div class="line">		temp.left = current.left;</div><div class="line">		temp.right = current.right;</div><div class="line">		tempParent.left = <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">actualDelete</span><span class="params">(TreeNode parent, TreeNode deleteNode, TreeNode next)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(parent.left == deleteNode)</div><div class="line">		parent.left = next;</div><div class="line">	<span class="keyword">else</span> </div><div class="line">		parent.right = next;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以用中序遍历输出有序序列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(TreeNode node)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</div><div class="line">		inOrder(node.left);</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; node.num; i++)</div><div class="line">			System.out.print(node.value + <span class="string">"--&gt;"</span>);</div><div class="line">		inOrder(node.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>二叉搜索树查找、插入的期望复杂度是 O(log n)，最坏情况下即退化成线性表的时候为 O(n)。</p>
]]></content>
    
    <summary type="html">
    
      本文主要介绍了二叉搜索树的基本知识。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>ARouter原理探析</title>
    <link href="http://yoursite.com/2019/10/24/ARouter%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/24/ARouter原理探析/</id>
    <published>2019-10-24T10:20:53.000Z</published>
    <updated>2019-10-24T13:21:33.902Z</updated>
    
    <content type="html"><![CDATA[<p><code>ARouter</code>是<code>alibaba</code>开源的组件化开发框架，在之前开发项目中也用到了，今天就来大致分析下其功能的流，这里以分析创建<code>Provider</code>为例。<br>首先我们在<code>base</code>模块中定义了一个<code>Factory</code>获取<code>Proivder</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleProviderFactory</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取模块Provider</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends IProvider&gt; <span class="function">T <span class="title">getModuleProvider</span><span class="params">(String providerName)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> (T) ARouter.getInstance().build(providerName).navigation();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以及为不同的 module 创建了<code>Provider</code>，这些<code>Provider</code>中定义了需要实现的行为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IModuleAProvider</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面这个是<code>ModuleA</code>的<code>Provider</code>，我们来看看<code>ModuleA</code>中的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Route</span>(path = ProviderPath.PROVIDE_MODULEA)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModuleAProvider</span> <span class="keyword">implements</span> <span class="title">IModuleAProvider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ProviderPath</code>中定义了<code>Provider</code>的获取路径，在<code>base</code>模块中创建，假如在另一个<code>ModuleB</code>想调用<code>ModuleA</code>暴露出来的接口，就可以如下方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IModuleAProvider iModuleAProvider = ModuleProviderFactory.getModuleProvider(ProviderPath.PROVIDE_MODULEA);</div><div class="line">iModuleAProvider.sayHello(<span class="string">""</span>);</div></pre></td></tr></table></figure></p>
<p><code>iModuleAProvider</code>指向通过调用<code>ARouter.getInstance().build(providerName).navigation()</code>返回的实例，我们先来看其初始化流程，在<code>Application</code>中我们会调用<code>ARouter.init(this);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!hasInit) &#123;</div><div class="line">        logger = _ARouter.logger;</div><div class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init start."</span>);</div><div class="line">        hasInit = _ARouter.init(application);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (hasInit) &#123;</div><div class="line">            _ARouter.afterInit();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init over."</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一步判断有没有初始化过，如果没有，会调用<code>_ARouter.init(application);</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</div><div class="line">    mContext = application;</div><div class="line">    LogisticsCenter.init(mContext, executor);</div><div class="line">    logger.info(Consts.TAG, <span class="string">"ARouter init success!"</span>);</div><div class="line">    hasInit = <span class="keyword">true</span>;</div><div class="line">    mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法中保存了<code>application</code>以及创建了一个主线程<code>mHandler</code>，以及调用<code>LogisticsCenter.init(mContext, executor);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException </span>&#123;</div><div class="line">    mContext = context;</div><div class="line">    executor = tpe;</div><div class="line"></div><div class="line">    <span class="comment">//...此处省略部分代码</span></div><div class="line">    Set&lt;String&gt; routerMap;</div><div class="line"></div><div class="line">    <span class="comment">// It will rebuild router map every times when debuggable.</span></div><div class="line">    <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</div><div class="line">        logger.info(TAG, <span class="string">"Run with debug mode or new install, rebuild router map."</span>);</div><div class="line">        <span class="comment">// These class was generated by arouter-compiler.</span></div><div class="line">        routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</div><div class="line">        <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</div><div class="line">            context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        PackageUtils.updateVersion(context);    <span class="comment">// Save new version name when router map update finishes.</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        logger.info(TAG, <span class="string">"Load router map from cache."</span>);</div><div class="line">        routerMap = <span class="keyword">new</span> HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class="keyword">new</span> HashSet&lt;String&gt;()));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">    <span class="keyword">for</span> (String className : routerMap) &#123;</div><div class="line">        <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</div><div class="line">            <span class="comment">// This one of root elements, load root.</span></div><div class="line">            ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</div><div class="line">            <span class="comment">// Load interceptorMeta</span></div><div class="line">            ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</div><div class="line">            <span class="comment">// Load providerIndex</span></div><div class="line">            ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//...此处省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先判断是否开启了<code>Debug</code>模式或者版本号是否有更新，两条件满足其一，则<code>ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</code>这个方法会放在线程池中的子线程执行，就是获取到所有以<code>com.alibaba.android.arouter.routes</code>为头部的<code>class</code>路径（即通过编译时注解生成对应的 class 文件）的集合，如果不为空则保存到 SP 文件中，如果两个条件没一个满足的话，则会从 SP 中获取之前保存的集合。然后遍历集合，刷选出特定路径，获取到<code>class</code>实例通过构造器创建对象，调用<code>loadInto</code>方法，比如可以在<code>/modulea/build/generated/ap_generated_sources/debug/out/com/alibaba/android/arouter/routes</code>下找到符合该规则的<code>ARouter$$Root$$modulea</code>调用<code>loadInto</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</div><div class="line">  routes.put(<span class="string">"modulea"</span>, ARouter$$Group$$modulea.class);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ARouter$$Group$$modulea</code>也是编译生成的类，<code>routes</code>即<code>Warehouse.groupsIndex</code>，接着看其内部<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Warehouse</span> </span>&#123;</div><div class="line">    <span class="comment">// Cache route and metas</span></div><div class="line">    <span class="keyword">static</span> Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; groupsIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; routes = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// Cache provider</span></div><div class="line">    <span class="keyword">static</span> Map&lt;Class, IProvider&gt; providers = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">    <span class="keyword">static</span> Map&lt;String, RouteMeta&gt; providersIndex = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="comment">// Cache interceptor</span></div><div class="line">    <span class="keyword">static</span> Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; interceptorsIndex = <span class="keyword">new</span> UniqueKeyTreeMap&lt;&gt;(<span class="string">"More than one interceptors use same priority [%s]"</span>);</div><div class="line">    <span class="keyword">static</span> List&lt;IInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">        routes.clear();</div><div class="line">        groupsIndex.clear();</div><div class="line">        providers.clear();</div><div class="line">        providersIndex.clear();</div><div class="line">        interceptors.clear();</div><div class="line">        interceptorsIndex.clear();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个类的作用就是用来存储的，像<code>ARouter$$Group$$modulea.class</code>就保存在<code>groupsIndex</code>中，至于<code>ARouter$$Group$$modulea</code>中的逻辑我们后面会看到，初始化流程就是如此了，接着我们来分析下<code>ARouter.getInstance().build(providerName).navigation()</code>，<br><code>getInstance()</code>方法会获取到<code>ARouter</code>的实例，下一步调用<code>build(provideName)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> _ARouter.getInstance().build(path);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实就是调用了<code>_ARouter</code>实例的<code>build</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</div><div class="line">            path = pService.forString(path);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> build(path, extractGroup(path));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们没有定义<code>PathReplaceService</code>，继续<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path, String group)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</div><div class="line">            path = pService.forString(path);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Postcard(path, group);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>extractGroup</code>方法获取到的是第一对“/ ”之间的字串，代表着<code>group</code>名称，比如这里“/modulea/provider”中的<code>modulea</code>，最后会通过“/modulea/provider”和<code>modulea</code>创建一个<code>Postcard</code>实例，<code>Postcard</code>是<code>RouteMeta</code>的子类，而<code>RouteMeta</code>保存的是路由的信息。ok得到这个实例之后调用了<code>Postcard</code>的<code>navigation()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> navigation(<span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> navigation(context, <span class="keyword">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context context, NavigationCallback callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> ARouter.getInstance().navigation(context, <span class="keyword">this</span>, -<span class="number">1</span>, callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终调用<code>ARouter</code>的<code>navigation</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context mContext, Postcard postcard, <span class="keyword">int</span> requestCode, NavigationCallback callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后又回到了<code>_ARouter</code>调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</div><div class="line">    <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        LogisticsCenter.completion(postcard);</div><div class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</div><div class="line">        <span class="comment">//...此处省略部分代码</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</div><div class="line">        callback.onFound(postcard);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></div><div class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</div><div class="line">           </div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</div><div class="line">                _navigation(context, postcard, requestCode, callback);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</div><div class="line">                    callback.onInterrupt(postcard);</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                logger.info(Consts.TAG, <span class="string">"Navigation failed, termination by interceptor : "</span> + exception.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看看<code>LogisticsCenter.completion(postcard);</code>中的逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</div><div class="line">    <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">    <span class="comment">//根据完整路径获取 routeMeta 对象</span></div><div class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123; </div><div class="line">    	<span class="comment">//如果没有获取到路由的缓存对象，那么获取缓存中在初始化的时候保存的 class 即 ARouter$$Group$$modulea</span></div><div class="line">        Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// Load route meta.</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"There is no route match the path ["</span> + postcard.getPath() + <span class="string">"], in group ["</span> + postcard.getGroup() + <span class="string">"]"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Load route and cache it into memory, then delete from metas.</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">                <span class="comment">//通过构造器创建 ARouter$$Group$$modulea 实例</span></div><div class="line">                IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</div><div class="line"></div><div class="line">                <span class="comment">//把 IRouteGroup 实现类的实例中保存的路由信息放到 Warehouse 缓存中</span></div><div class="line">                <span class="comment">//比如 ARouter$$Group$$modulea 中的 </span></div><div class="line">                <span class="comment">// atlas.put("/modulea/provider", RouteMeta.build(RouteType.PROVIDER, ModuleAProvider.class, "/modulea/provider", "modulea", null, -1, -2147483648));</span></div><div class="line">                iGroupInstance.loadInto(Warehouse.routes);</div><div class="line"></div><div class="line">                <span class="comment">//移除对应 Group 的缓存，即 ARouter$$Group$$modulea</span></div><div class="line">                Warehouse.groupsIndex.remove(postcard.getGroup());</div><div class="line"></div><div class="line">                <span class="comment">//...此处省略部分代码</span></div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"Fatal exception when loading group meta. ["</span> + e.getMessage() + <span class="string">"]"</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//再次调用自身方法，此时路由信息已经不为空了，会走到下面的 else 里</span></div><div class="line">            completion(postcard);   <span class="comment">// Reload</span></div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">    	<span class="comment">// atlas.put("/modulea/provider", RouteMeta.build(RouteType.PROVIDER, ModuleAProvider.class, "/modulea/provider", "modulea", null, -1, -2147483648));</span></div><div class="line">    	<span class="comment">//routeMeta.getDestination()即ModuleAProvider.class</span></div><div class="line">        postcard.setDestination(routeMeta.getDestination());</div><div class="line"></div><div class="line">        <span class="comment">//routeMeta.getType()即RouteType.PROVIDER类型</span></div><div class="line">        postcard.setType(routeMeta.getType());</div><div class="line"></div><div class="line">        <span class="comment">//以下此例子中不关心</span></div><div class="line">        postcard.setPriority(routeMeta.getPriority());</div><div class="line">        postcard.setExtra(routeMeta.getExtra());</div><div class="line"></div><div class="line">        Uri rawUri = postcard.getUri();</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123;   <span class="comment">// Try to set params into bundle.</span></div><div class="line">            Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</div><div class="line">            Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</div><div class="line">                <span class="comment">// Set value by its type, just for params which annotation by @Param</span></div><div class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</div><div class="line">                    setValue(postcard,</div><div class="line">                            params.getValue(),</div><div class="line">                            params.getKey(),</div><div class="line">                            resultMap.get(params.getKey()));</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="comment">// Save params name which need auto inject.</span></div><div class="line">                postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> String[]&#123;&#125;));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Save raw uri</span></div><div class="line">            postcard.withString(ARouter.RAW_URI, rawUri.toString());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//根据路由类型执行不同逻辑</span></div><div class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</div><div class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></div><div class="line">                <span class="comment">// Its provider, so it must implement IProvider</span></div><div class="line">                <span class="comment">//通过路由信息获取到 ModuleAProvider.class</span></div><div class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</div><div class="line">          		<span class="comment">//第一次拿到的是 null</span></div><div class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></div><div class="line">                    IProvider provider;</div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                    	<span class="comment">//通过 ModuleAProvider.class 的构造器创建实例</span></div><div class="line">                        provider = providerMeta.getConstructor().newInstance();</div><div class="line">                        <span class="comment">//调用 ModuleAProvider 实例的 init 方法</span></div><div class="line">                        provider.init(mContext);</div><div class="line">                        <span class="comment">//将 Provider 放入缓存中</span></div><div class="line">                        Warehouse.providers.put(providerMeta, provider);</div><div class="line">                        instance = provider;</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//将 ModuleAProvider 实例放入 postcard 路由信息中</span></div><div class="line">                postcard.setProvider(instance);</div><div class="line">                postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> FRAGMENT:</div><div class="line">                postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></div><div class="line">            <span class="keyword">default</span>:</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>具体逻辑看代码注释了，大致就是编译生成的<code>Group</code>下的具体路径和路由信息放入<code>Warehouse</code>缓存中，如果没有则将路由信息放入缓存，并移除<code>Group</code>缓存，然后再一次调用自己，此时对应路径下已经有具体的路由信息了，此时会再将路由信息放入到传入参数<code>postcard</code>的路由信息中，如果是<code>Provider</code>类型，如果没有缓存还会创建实例设置到<code>postcard</code>，并放入<code>Warehouse</code>里缓存。<br>接下来调用<code>_navigation(context, postcard, requestCode, callback);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Context currentContext = <span class="keyword">null</span> == context ? mContext : context;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span> (postcard.getType()) &#123;</div><div class="line">        <span class="keyword">case</span> ACTIVITY:</div><div class="line">            <span class="comment">// Build intent</span></div><div class="line">            <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(currentContext, postcard.getDestination());</div><div class="line">            intent.putExtras(postcard.getExtras());</div><div class="line"></div><div class="line">            <span class="comment">// Set flags.</span></div><div class="line">            <span class="keyword">int</span> flags = postcard.getFlags();</div><div class="line">            <span class="keyword">if</span> (-<span class="number">1</span> != flags) &#123;</div><div class="line">                intent.setFlags(flags);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></div><div class="line">                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Set Actions</span></div><div class="line">            String action = postcard.getAction();</div><div class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(action)) &#123;</div><div class="line">                intent.setAction(action);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Navigation in main looper.</span></div><div class="line">            runInMainThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                    startActivity(requestCode, currentContext, intent, postcard, callback);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> PROVIDER:</div><div class="line">            <span class="keyword">return</span> postcard.getProvider();</div><div class="line">        <span class="keyword">case</span> BOARDCAST:</div><div class="line">        <span class="keyword">case</span> CONTENT_PROVIDER:</div><div class="line">        <span class="keyword">case</span> FRAGMENT:</div><div class="line">            Class fragmentMeta = postcard.getDestination();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Object instance = fragmentMeta.getConstructor().newInstance();</div><div class="line">                <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</div><div class="line">                    ((Fragment) instance).setArguments(postcard.getExtras());</div><div class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</div><div class="line">                    ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">return</span> instance;</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</div><div class="line">                logger.error(Consts.TAG, <span class="string">"Fetch fragment instance error, "</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">case</span> METHOD:</div><div class="line">        <span class="keyword">case</span> SERVICE:</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为我们<code>postcard.getType()</code>是<code>PROVIDER</code>类型的，所有直接返回了我们上一步在<code>postcard</code>中塞入创建的<code>ModuleAProvider</code>实例，接着就可以调用其<code>sayHello</code>方法了。<br>不难发现，其实在<code>ARouter</code>中<code>Group</code>的划分是以路径中第一对“/”中的字串作为基准的，一开始会将根据不同<code>Group</code>生成的<code>ARouter$$Group$$字串</code>的 class 放入<code>Warehouse</code>中缓存，然后根据调用的 path 将不同<code>Group</code>的具体路径对应的具体路由加载进<code>Warehouse</code>，再获取对应的<code>RouteMeta</code>路由信息，重新组装到<code>postcard</code>中，最后调用<code>_navigation</code>根据<code>postcard</code>不同的类型执行相应的逻辑。还有一点非常明显，当我们调用<code>ARouter</code>的方法的时候最终都会交由<code>_ARouter</code>去执行，这里用到的是结构性设计模式中的外观模式。<br>大致分析就是如此了。</p>
]]></content>
    
    <summary type="html">
    
      对 ARouter 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal简析</title>
    <link href="http://yoursite.com/2019/10/22/ThreadLocal%E7%AE%80%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/22/ThreadLocal简析/</id>
    <published>2019-10-22T10:29:45.000Z</published>
    <updated>2019-10-22T11:48:43.866Z</updated>
    
    <content type="html"><![CDATA[<p>首先先来看一段代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadId</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicInteger nextId = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; threadId =</div><div class="line">        <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> nextId.getAndIncrement();</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> threadId.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i  &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">				</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">					System.out.println(get());</div><div class="line">				&#125;</div><div class="line">			&#125;).start();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后控制台输出如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span></div><div class="line"><span class="number">5</span></div><div class="line"><span class="number">6</span></div><div class="line"><span class="number">8</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">0</span></div><div class="line"><span class="number">4</span></div><div class="line"><span class="number">3</span></div><div class="line"><span class="number">9</span></div><div class="line"><span class="number">7</span></div></pre></td></tr></table></figure></p>
<p>不难发现，不同的线程获取到的<code>threadId</code>是不一样的，那么为什么会出现这种情况呢，所以需要分析下<code>ThreadLocal</code>这个类，看看<code>threadId.get()</code>的逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</div><div class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> (T)e.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> setInitialValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一步获取当前线程实例，然后调用<code>getMap(t)</code>获取到<code>ThreadLocalMap</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> t.threadLocals;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>getMap(Thread t)</code>方法直接返回了当前线程实例中的<code>threadLocals</code>成员变量，继续<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<p>其实<code>threadLocals</code>是<code>ThreadLocal</code>中的静态内部类<code>ThreadLocalMap</code>类型，那么此时返回为<code>null</code>，接着调用<code>return setInitialValue();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</div><div class="line">    T value = initialValue();</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">    <span class="keyword">return</span> value;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时调用了重写的<code>initialValue()</code>方法进行<code>nextId</code>的自增操作，接着调用<code>createMap(t, value);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</div><div class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时创建了一个<code>ThreadLocalMap</code>实例并复制给当前线程的<code>threadLocals</code>变量，再来看其创建过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">ThreadLocalMap(ThreadLocal firstKey, Object firstValue) &#123;</div><div class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</div><div class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</div><div class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</div><div class="line">    size = <span class="number">1</span>;</div><div class="line">    setThreshold(INITIAL_CAPACITY);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里创建了一个初始长度为<code>INITIAL_CAPACITY</code>即长度为 16 的<code>Entry</code>类型数组，然后通过<code>firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);</code>获取到数组下标，创建<code>new Entry(firstKey, firstValue)</code>赋值到<code>table</code>的<code>i</code>位置，<code>size</code>记录的是数组中被赋值的个数，<code>setThreshold(INITIAL_CAPACITY);</code>是计算<code>threshold</code>的大小，即<code>INITIAL_CAPACITY * 2 / 3</code>，当<code>size</code>达到这个值时，<code>table</code>数组将会被扩容。接着我们来看看<code>Entry</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></div><div class="line">    Object value;</div><div class="line"></div><div class="line">    Entry(ThreadLocal k, Object v) &#123;</div><div class="line">        <span class="keyword">super</span>(k);</div><div class="line">        value = v;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Entry</code>是<code>ThreadLocal</code>的静态内部类，利用虚引用保存<code>ThreadLocal</code>实例，另外还保存了<code>value</code>值。<br><code>get</code>方法的流程大致就是如此了，首先会获取当前类中的<code>ThreadLocalMap</code>类型的<code>threadLocals</code>成员变量，如果为空则调用初始化方法，并且创建一个<code>ThreadLocalMap</code>实例赋值给当前线程，然后经过取余计算获取对应数组的位置创建<code>Entry</code>实例并赋值。<br><code>ThreadLocal</code>在<code>Android</code>中也有应用，在<code>Handler</code>机制中，当我们调用<code>Looper.prepare();</code>创建<code>Looper</code>的时候用到了<code>ThreadLocal</code>存储。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</div><div class="line">    prepare(<span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</div><div class="line">    &#125;</div><div class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中可以看出，一个线程最多只能创建一个<code>Looper</code>实例，不然会抛出异常，那么我们接下里就来分析下<code>ThreadLocal</code>的<code>set</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</div><div class="line">    Thread t = Thread.currentThread();</div><div class="line">    ThreadLocalMap map = getMap(t);</div><div class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</div><div class="line">        map.set(<span class="keyword">this</span>, value);</div><div class="line">    <span class="keyword">else</span></div><div class="line">        createMap(t, value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>逻辑和<code>get</code>方法一样先获取当前线程的<code>threadLocals</code>，如果为空和上面的流程一样，这里就不再讲了，接下来看看<code>map.set(this, value);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal key, Object value)</span> </span>&#123;</div><div class="line"></div><div class="line">    Entry[] tab = table;</div><div class="line">    <span class="keyword">int</span> len = tab.length;</div><div class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (Entry e = tab[i];</div><div class="line">         e != <span class="keyword">null</span>;</div><div class="line">         e = tab[i = nextIndex(i, len)]) &#123;</div><div class="line">        ThreadLocal k = e.get();</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == key) &#123;</div><div class="line">            e.value = value;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</div><div class="line">            replaceStaleEntry(key, value, i);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</div><div class="line">    <span class="keyword">int</span> sz = ++size;</div><div class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</div><div class="line">        rehash();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>大致就是先根据<code>key</code>即<code>ThreadLocal</code>实例的<code>threadLocalHashCode</code>获取到需要赋值数组的位置，然后判断是否有实例存在，有则覆盖<code>value</code>值，没有则创建一个<code>Entry</code>实例赋值到对应位置，最后判断需不需要<code>resize</code>…<br><code>ThreadLocal</code>在我看来其实就是作用于线程范围的类，适用于不同的线程需要创建不同的数据副本情况，比如说<code>Android</code>中的<code>Looper</code>，暂时还未想到在<code>Andriod</code>实际开发中需要用到<code>ThreadLocal</code>的业务场景。</p>
]]></content>
    
    <summary type="html">
    
      对 ThreadLocal 的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags%C3%9F/Java/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 排序算法之堆排序</title>
    <link href="http://yoursite.com/2019/10/21/%E9%87%8D%E6%8B%BE-DSA-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2019/10/21/重拾-DSA-排序算法之堆排序/</id>
    <published>2019-10-21T08:23:47.000Z</published>
    <updated>2019-10-22T11:11:06.970Z</updated>
    
    <content type="html"><![CDATA[<p>Heapsort（堆排序），顾名思义是基于堆数据结构的一种排序算法，了解堆之前我们需要了解什么是二叉树和完全二叉树，二叉树在之前关于树的文章中有简单介绍（<a href="https://lucien623.github.io/2017/08/19/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E6%A0%91/" target="_blank" rel="external">click here</a>），简单来说就是每个节点最多含有两个子树的树称为二叉树，完全二叉树则是深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边的二叉树，那么堆除了有何完全二叉树同样的性质外，还有一个特殊的性质，即子结点的键值或索引总是小于（或者大于）等于它的父节点。堆一般分为两种，大顶堆和小顶堆。大顶堆指堆中的每个父节点都大于等于其孩子节点，根节点即最大元素，小顶堆则和大顶堆相反，每个父节点小于等于其孩子节点，根节点即最小元素。当我们以数组的形式保存堆时，即有以下性质 array[i] &gt;= array[2 * i + 1] &amp;&amp; array[i] &gt;= array[2 * i + 1] 或者 array[i] &lt;= array[2 * i + 1] &amp;&amp; array[i] &lt;= array[2 * i + 1]，这里假设 2 * i + 1 和 2 * i + 1 的元素都存在，有了这样的性质我们就可以来构建大顶堆或者小顶堆了，这里我们以构建大顶堆为例，大致思路是先从最后一个非叶子节点开始调整堆直到调整到根节点位置，那么最后一个非叶子节点如何得到呢，其实只要用数组的 length / 2 - 1 就可以计算出下标了，来看看代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> array 待调整数组</div><div class="line"> * <span class="doctag">@param</span> i 需要调整的元素</div><div class="line"> * <span class="doctag">@param</span> length 待调整数组长度</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> i, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span> * i + <span class="number">1</span>; j &lt; length; j = <span class="number">2</span> * j + <span class="number">1</span>) &#123;</div><div class="line">		<span class="keyword">int</span> temp = array[i];</div><div class="line">		<span class="keyword">if</span>(j + <span class="number">1</span> &lt; length &amp;&amp; array[j + <span class="number">1</span>] &gt; array[j])</div><div class="line">			j = j + <span class="number">1</span>;</div><div class="line">		<span class="keyword">if</span>(temp &lt; array[j]) &#123;</div><div class="line">			swap(array, i, j);</div><div class="line">			i = j;</div><div class="line">		&#125; <span class="keyword">else</span> &#123;</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= array.length || j &gt;= array.length)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="keyword">int</span> temp = array[i];</div><div class="line">	array[i] = array[j];</div><div class="line">	array[j] = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后我们从最后一个非叶子节点开始调整<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> length = array.length;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = length / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">	adjustHeap(array, i, length);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样大顶堆就构建完成了。ok，堆排序的思路是每次构建完大顶堆的时候，把根节点和待排序数组的最后一个数进行交换，然后再根据根节点重新调整成大顶堆，直到排序完成。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> last = length - <span class="number">1</span>;last &gt; <span class="number">0</span>; last--) &#123;</div><div class="line">	swap(array, <span class="number">0</span>, last);</div><div class="line">	adjustHeap(array, <span class="number">0</span>, last);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>堆排序的大致介绍就是如此了，其最好最坏的时间复杂度均为 O(nlogn)。</p>
]]></content>
    
    <summary type="html">
    
      关于堆排序的简单介绍和 Java 实现。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Java线程池ThreadPoolExecutor介绍</title>
    <link href="http://yoursite.com/2019/10/20/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E4%BB%8B%E7%BB%8D/"/>
    <id>http://yoursite.com/2019/10/20/Java线程池ThreadPoolExecutor介绍/</id>
    <published>2019-10-20T08:40:32.000Z</published>
    <updated>2019-10-20T10:36:34.176Z</updated>
    
    <content type="html"><![CDATA[<p>线程池常用于需要频繁创建和销毁线程的情况，因为创建和销毁线程都需要消耗时间，如果经常性这样操作，对于性能肯定是非常有影响的，<code>ThreadPoolExecutor</code>能够帮助我们创建线程池，帮助我们管理维护线程，先看看<code>ThreadPoolExecutor</code>在<code>OkHttp</code>中的使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</div><div class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</div></pre></td></tr></table></figure></p>
<p>分析下在创建<code>ThreadPoolExecutor</code>时的几个参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></div><div class="line">                          <span class="keyword">int</span> maximumPoolSize,</div><div class="line">                          <span class="keyword">long</span> keepAliveTime,</div><div class="line">                          TimeUnit unit,</div><div class="line">                          BlockingQueue&lt;Runnable&gt; workQueue,</div><div class="line">                          ThreadFactory threadFactory,</div><div class="line">                          RejectedExecutionHandler handler) &#123;</div><div class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt;= <span class="number">0</span> ||</div><div class="line">        maximumPoolSize &lt; corePoolSize ||</div><div class="line">        keepAliveTime &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</div><div class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</div><div class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</div><div class="line">    <span class="keyword">this</span>.workQueue = workQueue;</div><div class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</div><div class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</div><div class="line">    <span class="keyword">this</span>.handler = handler;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>corePoolSize</code>：线程池中的核心线程数，除非设置了<code>allowCoreThreadTimeOut</code>，否则它们一旦创建就不会被销毁（the number of threads to keep in the pool, even if they are idle, unless {@code allowCoreThreadTimeOut} is set）</p>
<p><code>maximumPoolSize</code>：线程池中的最大线程数量（the maximum number of threads to allow in the pool）</p>
<p><code>keepAliveTime</code>：当线程池中的数量超过核心线程数时，闲置线程可以存活的最大时间（when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.）</p>
<p><code>unit</code>：<code>keepAliveTime</code>最大限制时间的单位（the time unit for the {@code keepAliveTime} argument）</p>
<p><code>workQueue</code>：线程等待执行的队列，常见的有<code>ArrayBlockingQueue</code>(基于数组实现的 FIFO 阻塞队列)，<code>LinkedBlockingQueue</code>（基于链表实现的 FIFO 阻塞队列），<code>SynchronousQueue</code>（没有任何容量的阻塞队列），<code>PriorityQueue</code>（具有优先级的无限阻塞队列）（the queue to use for holding tasks before they are executed.  This queue will hold only the {@code Runnable} tasks submitted by the {@code execute} method.）</p>
<p><code>threadFactory</code>：创建线程的工厂，当这个参数不传时，会用默认的<code>DefaultThreadFactory</code>作为线程创建工厂（the factory to use when the executor creates a new thread）</p>
<p><code>handler</code>：默认是<code>new AbortPolicy();</code>，当任务队列已满并且无法创建新线程的时候会抛<code>RejectedExecutionException</code>异常（the handler to use when execution is blocked because the thread bounds and queue capacities are reached）</p>
<p>要提交任务只需调用<code>execute(Runnable runnable)</code>方法即可。关闭线程池有两种方法，<code>shutdown()</code>会中断没有正在执行任务的线程，正在执行的不中断,<code>shutdownNow()</code>会中断所有任务的线程。</p>
<p>线程池的执行流程大致是这样的：，当我们提交任务时，先去判断核心线程池是否已满，若未达到<code>corePoolSize</code>，那么会创建一个新线程执行任务，如果已经达到了核心线程数，那么便判断工作队列是否已满，如果没有满，那么将任务放入工作队列中，满了则继续下一个判断，即判断线程池的数量是否已经超过最大线程数<code>maximumPoolSize</code>，没有超过则创建一个新线程执行任务，如果超过的话就执行线程饱和策略。</p>
<p>除了自己创建线程池外，<code>Executors</code>也提供了四种快速创建线程池的方法：</p>
<p><em>Executors.newFixedThreadPool();</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</div><div class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>newFixedThreadPool</code>创建了一个仅含有<code>nThreads</code>个核心线程的线程池，当核心线程池满时，新提交的任务会放入一个无大小限制的阻塞队列。</p>
<p><em>Executors.newSingleThreadExecutor();</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</div><div class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</div><div class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</div><div class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>newSingleThreadExecutor</code>创建了只允许有一个线程的线程池，如果线程池已满，那么会把新提交的任务放入一个无大小限制的阻塞队列中，这些任务会顺序执行，不会产生并发问题。</p>
<p><em>Executors.newCachedThreadPool();</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</div><div class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</div><div class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>newCachedThreadPool</code>创建的线程池没有大小限制，任何新提交的任务都会新创建线程执行，处于闲置状态的线程在 60s 后将会被销毁，<code>OkHttp</code>创建线程池的策略和这个相同，只不过<code>OkHttp</code>自己定义了一个创建线程的工厂。</p>
<p><em>Executors.newScheduledThreadPool();</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</div><div class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</div><div class="line">          <span class="keyword">new</span> DelayedWorkQueue());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>newScheduledThreadPool</code>创建的线程池核心线程数由自己定义，线程池大小没有任何限定，闲置线程只能存活 10 毫秒，几乎一闲置就会被回收，这种方式创建的线程池还可以执行定时任务。</p>
<p>创建线程池的策略大致如此，如果是 CPU 密集型任务，那么配置 CPU 核数 + 1 个线程数的线程池，如果是 IO 密集型，那么配置 CPU 核数 * 2 个线程数的线程池。</p>
]]></content>
    
    <summary type="html">
    
      ThreadPoolExecutor 介绍。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags%C3%9F/Java/"/>
    
  </entry>
  
  <entry>
    <title>ButterKnife原理探析</title>
    <link href="http://yoursite.com/2019/10/19/ButterKnife%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/19/ButterKnife原理探析/</id>
    <published>2019-10-19T11:03:09.000Z</published>
    <updated>2019-10-19T12:46:01.913Z</updated>
    
    <content type="html"><![CDATA[<p><code>ButterKnife</code>是<code>Android</code>开发中常用的<code>View</code>注入框架，主要作用就是减少<code>findViewById</code>代码，使其更简洁。在分析这个框架之前我们先要了解一下<code>Annotation</code> 注解相关的知识。</p>
<p>注解是<code>Java</code>语言 5.0 版本开始支持加入源代码的特殊语法元数据。<code>Java</code>语言中的类、方法、变量、参数和包等都可以被标注。主要有三个作用，第一种作用是标记用来告诉编译器一些信息；第二种是编译时处理动态生成代码；第三种是运行时动态处理得到注解信息。注解主要分为三类：</p>
<p>标准注解：是<code>Java</code>自带的一些注解，比如<code>@Override</code>、<code>@Deprecated</code></p>
<p>元注解：指用来定义自定义注解的注解，<code>@Retention</code>表示注解的保留时间，<code>SOURCE</code>表示源码时保留编译后会被抛弃，<code>CLASS</code>表示编译时保留运行时会被丢弃，<code>RUNTIME</code>表示运⾏时保留。<code>@Target</code>用来表示注解可以修饰哪些元素，比如<code>TYPE</code>(类、接口)，<code>FIELD</code>（字段），<code>METHOD</code>（方法），<code>CONSTRUCTOR</code>（构造方法）, <code>PARAMETER</code>（参数申明）等。<code>@Inherited</code>表示是否可以被继承，<code>@Documented</code>是否会保存到⽂档。</p>
<p>自定义注解：通过元注解定义的注解，我们来看以下<code>ButterKnife</code>中的一个自定义注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Retention</span>(CLASS) </div><div class="line"><span class="meta">@Target</span>(FIELD)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> BindView &#123;</div><div class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></div><div class="line">  <span class="meta">@IdRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到这个注解会在编译时被保留<code>@Retention(CLASS)</code>，目标是对于字段<code>@Target(FIELD)</code>，注解的类型是<code>int</code>类型的<code>id</code>资源。</p>
<p>好了，注解大概就分析这些，接下来来看看<code>ButterKnife</code>是如何实现的。</p>
<p>首先<code>ButterKnife</code>不仅可以注入<code>View</code>，还可以绑定资源，点击事件等等，使用方式就不一一讲解了，ok，那么我们以绑定<code>view</code>为例，比如我们在<code>LoanFragment</code>里添加了如下代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@BindView</span>(R.id.text_title) TextView mTextTitle;</div></pre></td></tr></table></figure></p>
<p>然后我们在初始化的时候调用绑定<code>ButterKnife.bind(this, mFragmentView);</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> View <span class="title">onCreateView</span><span class="params">(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">    TAG = <span class="keyword">this</span>.getClass().getSimpleName();</div><div class="line">    <span class="keyword">if</span> (mFragmentView == <span class="keyword">null</span>) &#123;</div><div class="line">        mFragmentView = inflater.inflate(getLayoutId(), container, <span class="keyword">false</span>);</div><div class="line">        unbinder = ButterKnife.bind(<span class="keyword">this</span>, mFragmentView);</div><div class="line">        initView(mFragmentView);</div><div class="line">        initData();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> mFragmentView;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着看<code>bind</code>方法里的逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span> <span class="meta">@UiThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull Object target, @NonNull View source)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> createBinding(target, source);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unbinder <span class="title">createBinding</span><span class="params">(@NonNull Object target, @NonNull View source)</span> </span>&#123;</div><div class="line">  Class&lt;?&gt; targetClass = target.getClass();</div><div class="line">  <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up binding for "</span> + targetClass.getName());</div><div class="line">  Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> Unbinder.EMPTY;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span></div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">return</span> constructor.newInstance(target, source);</div><div class="line">  &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</div><div class="line">  &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</div><div class="line">  &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">    Throwable cause = e.getCause();</div><div class="line">    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</div><div class="line">      <span class="keyword">throw</span> (RuntimeException) cause;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</div><div class="line">      <span class="keyword">throw</span> (Error) cause;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create binding instance."</span>, cause);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一步获取到<code>LoanFragment</code>的<code>Class</code>实例，接着调用<code>findBindingConstructorForClass</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Nullable</span> <span class="meta">@CheckResult</span> <span class="meta">@UiThread</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</div><div class="line">  Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</div><div class="line">  <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Cached in binding map."</span>);</div><div class="line">    <span class="keyword">return</span> bindingCtor;</div><div class="line">  &#125;</div><div class="line">  String clsName = cls.getName();</div><div class="line">  <span class="keyword">if</span> (clsName.startsWith(<span class="string">"android."</span>) || clsName.startsWith(<span class="string">"java."</span>)) &#123;</div><div class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"MISS: Reached framework class. Abandoning search."</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    Class&lt;?&gt; bindingClass = cls.getClassLoader().loadClass(clsName + <span class="string">"_ViewBinding"</span>);</div><div class="line">    <span class="comment">//noinspection unchecked</span></div><div class="line">    bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</div><div class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Loaded binding class and constructor."</span>);</div><div class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Not found. Trying superclass "</span> + cls.getSuperclass().getName());</div><div class="line">    bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</div><div class="line">  &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to find binding constructor for "</span> + clsName, e);</div><div class="line">  &#125;</div><div class="line">  BINDINGS.put(cls, bindingCtor);</div><div class="line">  <span class="keyword">return</span> bindingCtor;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一步是为了获取相对应类的构造器，<code>BINDINGS</code>是一个保存着<code>Class</code>实例和构造器相映射的<code>map</code>，进入这个方法会先去判断之前是否已经获取过该<code>Class</code>实例的构造器，如果有则直接<code>return</code>，否则获取到该类的名称，通过该<code>Class</code>实例的类加载器把<code>clsName + &quot;_ViewBinding&quot;</code>加载，再通过这个<code>Class</code>实例获取到相应的构造器返回并放入<code>BINDINGS</code>中，<code>clsName + &quot;_ViewBinding&quot;</code>到底是什么呢，其实在编译之后我们可以在<code>build/generated/source/apt</code>路径下可以找到<code>LoanFragment_ViewBinding</code>这个类，正好是这个拼接字符串的格式，拿到构造器之后会通过<code>return constructor.newInstance(target, source);</code>构建出相应实例，那么继续看这个构造方法里执行了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@UiThread</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoanFragment_ViewBinding</span><span class="params">(LoanFragment target, View source)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>.target = target;</div><div class="line"></div><div class="line">  target.mTextTitle = Utils.findRequiredViewAsType(source, R.id.text_title, <span class="string">"field 'mTextTitle'"</span>, TextView.class);</div><div class="line">  <span class="comment">//...此处省略部分代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">findRequiredViewAsType</span><span class="params">(View source, @IdRes <span class="keyword">int</span> id, String who,</span></span></div><div class="line">    Class&lt;T&gt; cls) &#123;</div><div class="line">  View view = findRequiredView(source, id, who);</div><div class="line">  <span class="keyword">return</span> castView(view, id, who, cls);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> View <span class="title">findRequiredView</span><span class="params">(View source, @IdRes <span class="keyword">int</span> id, String who)</span> </span>&#123;</div><div class="line">  View view = source.findViewById(id);</div><div class="line">  <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> view;</div><div class="line">  &#125;</div><div class="line">  String name = getResourceEntryName(source, id);</div><div class="line">  <span class="comment">//...此处省略部分代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>很明显了，如果是注入<code>view</code>的话最终还是调用<code>source.findViewById(id)</code>方式获取到的，<code>target.mTextTitle</code>即我们在<code>LoanFragment</code>中定义的<code>mTextTitle</code>，<code>target</code>是我们调用<code>bind</code>方法是传进来的<code>LoanFragment</code>实例。当<code>Activity</code>调用<code>bind</code>方法时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AboutUsActivity_ViewBinding</span><span class="params">(AboutUsActivity target)</span> </span>&#123;</div><div class="line">  <span class="keyword">this</span>(target, target.getWindow().getDecorView());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里可以看到会获取当前<code>Activity</code>的<code>DecorView</code>，即最顶层布局作为<code>source</code>调用<code>findViewById</code>的。<code>bind</code>的整体流程大致就是如此了，至于那些编译时的注入类主要依靠的是 apt 工具生成的，就暂时不展开了。</p>
<p>参考文章：<br><a href="http://trinea.github.io/download/pdf/android/java-annotation.pdf" target="_blank" rel="external">http://trinea.github.io/download/pdf/android/java-annotation.pdf</a></p>
]]></content>
    
    <summary type="html">
    
      对 ButterKnife 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>OkHttp原理探析</title>
    <link href="http://yoursite.com/2019/10/18/OkHttp%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/18/OkHttp原理探析/</id>
    <published>2019-10-18T06:34:28.000Z</published>
    <updated>2019-10-20T09:41:39.590Z</updated>
    
    <content type="html"><![CDATA[<p><code>OkHttp</code>是最近几年在安卓开发中运用比较广泛的开源网络框架，支持同步和异步请求，本文主要分析平常开发中运用得比较多的异步请求流程。首先来看下开启一个异步请求的流程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OkHttpClient okHttpClient = <span class="keyword">new</span> OkHttpClient();</div></pre></td></tr></table></figure></p>
<p>第一步创建<code>OkHttpClient</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Request request = <span class="keyword">new</span> Request.Builder().url(<span class="string">"https://lucien623.github.io/"</span>).build();</div></pre></td></tr></table></figure></p>
<p>第二步创建<code>Request</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">okHttpClient.newCall(request).enqueue(<span class="keyword">new</span> okhttp3.Callback() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(okhttp3.Call call, IOException e)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(okhttp3.Call call, okhttp3.Response response)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>第三步调用<code>okHttpClient</code>的<code>newCall</code>方法，并把<code>request</code>传入，再接着调用<code>enqueue</code>方法即开始异步请求了。<br>先暂时不分析<code>OkHttpClient</code>这个类，来看看<code>Request</code>的创建过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    HttpUrl url;</div><div class="line">    String method;</div><div class="line">    Headers.Builder headers;</div><div class="line">    RequestBody body;</div><div class="line">    Object tag;</div><div class="line"></div><div class="line">    <span class="comment">//...此处省略部分代码</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">url</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"url == null"</span>);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"ws:"</span>, <span class="number">0</span>, <span class="number">3</span>)) &#123;</div><div class="line">        url = <span class="string">"http:"</span> + url.substring(<span class="number">3</span>);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url.regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, <span class="string">"wss:"</span>, <span class="number">0</span>, <span class="number">4</span>)) &#123;</div><div class="line">        url = <span class="string">"https:"</span> + url.substring(<span class="number">4</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      HttpUrl parsed = HttpUrl.parse(url);</div><div class="line">      <span class="keyword">if</span> (parsed == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unexpected url: "</span> + url);</div><div class="line">      <span class="keyword">return</span> url(parsed);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">   <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (url == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"url == null"</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Request(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>就是通过建造者模式构建一个实例，对我们传入的<code>URL</code>地址进行了一个判断，如果是<code>web socket</code>形式的地址，会被转换成<code>http</code>或<code>https</code>形式的地址，<br>接着我们来看看<code>newCall(request)</code>过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到构建返回了一个<code>RealCall</code>实例，<code>newCall</code>方法其实是定义在<code>Call</code>接口中的工厂方法接口，接着看<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">RealCall(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket) &#123;</div><div class="line">  <span class="keyword">final</span> EventListener.Factory eventListenerFactory = client.eventListenerFactory();</div><div class="line"></div><div class="line">  <span class="keyword">this</span>.client = client;</div><div class="line">  <span class="keyword">this</span>.originalRequest = originalRequest;</div><div class="line">  <span class="keyword">this</span>.forWebSocket = forWebSocket;</div><div class="line">  <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</div><div class="line"></div><div class="line">  <span class="comment">// TODO(jwilson): this is unsafe publication and not threadsafe.</span></div><div class="line">  <span class="keyword">this</span>.eventListener = eventListenerFactory.create(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>RealCall</code>实例包含了之前创建的<code>OkHttpClient</code>和<code>Request</code>实例，并创建了一个<code>RetryAndFollowUpInterceptor</code>拦截器，这个我们之后可以分析到，<code>RealCall</code>实现了<code>Call</code>接口中的方法，包括接下来要调用<code>RealCall</code>中的<code>enqueue</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</div><div class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">    <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</div><div class="line">    executed = <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line">  captureCallStackTrace();</div><div class="line">  client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先会判断当前的<code>RealCall</code>对象是否已经执行过同步或者异步方法，如果执行过的会就会抛出”Already Executed”的异常，这一步可以得出每一个创建的<code>Call</code>都只能够执行一次请求，接着我们可以看到调用<code>client.dispatcher()</code>执行了<code>enqueue</code>方法，就是通过<code>OkHttpClient</code>实例获取到了一个<code>Dispatcher</code>实例，然后再调用这个方法，我们暂时不管<code>Dispatcher</code>，先看<code>new AsyncCall(responseCallback)</code>是个啥，<code>responseCallback</code>是我们在调用异步请求方法的时候传递的一个回调，接着看<code>AsyncCall</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</div><div class="line"></div><div class="line">  AsyncCall(Callback responseCallback) &#123;</div><div class="line">    <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</div><div class="line">    <span class="keyword">this</span>.responseCallback = responseCallback;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> originalRequest.url().host();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> originalRequest;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Response response = getResponseWithInterceptorChain();</div><div class="line">      <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</div><div class="line">        signalledCallback = <span class="keyword">true</span>;</div><div class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        signalledCallback = <span class="keyword">true</span>;</div><div class="line">        responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">      <span class="keyword">if</span> (signalledCallback) &#123;</div><div class="line">        <span class="comment">// Do not signal the callback twice!</span></div><div class="line">        Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">      client.dispatcher().finished(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>NamedRunnable</code>其实就是个实现了<code>Runnable</code>接口的抽象类，在<code>NamedRunnable</code>重写的<code>run()</code>方法中调用了<code>AsyncCall</code>中的<code>execute();</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">  String oldName = Thread.currentThread().getName();</div><div class="line">  Thread.currentThread().setName(name);</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    execute();</div><div class="line">  &#125; <span class="keyword">finally</span> &#123;</div><div class="line">    Thread.currentThread().setName(oldName);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>这个时候我们就大致可以知道<code>Dispatcher</code>里面肯定有个<code>Thread</code>，或者线程池了，其实他就是个任务调度器，英文的字面意思不就是这样么= =，我们接着看它调用<code>enqueue</code>方法是怎么执行的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</div><div class="line">    runningAsyncCalls.add(call);</div><div class="line">    executorService().execute(call);</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    readyAsyncCalls.add(call);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Dispatcher</code>实例是在创建<code>OkHttpClient</code>时 new 的，初始化时创建了三个队列<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Ready async calls in the order they'll be run. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; readyAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;AsyncCall&gt; runningAsyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div><div class="line"></div><div class="line"><span class="comment">/** Running synchronous calls. Includes canceled calls that haven't finished yet. */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Deque&lt;RealCall&gt; runningSyncCalls = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</div></pre></td></tr></table></figure></p>
<p><code>readyAsyncCalls</code>表示等待执行异步请求队列，<code>runningAsyncCalls</code>是正在执行异步请求中的队列，<code>runningSyncCalls</code>是正在执行同步请求的队列，再回到上面先判断当前正在执行异步请求的数量有没有小于最大的异步请求数<code>maxRequests</code>即 64 个，然后判断当前<code>host</code>的异步请求数是否超过了<code>maxRequestsPerHost</code>即 5 个，如果不满足其中一个条件就把<code>call</code>放入待执行异步任务队列中，如果同时满足的话，就把当前的<code>call</code>放入正在执行异步请求队列中，然后执行<code>executorService().execute(call);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</div><div class="line">    executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</div><div class="line">        <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> executorService;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>终于线程池的真面目露出来了，这里创建了一个线程池大小为<code>Integer.MAX_VALUE</code>即 2^31 - 1，如果有线程闲置 60 秒即被回收，内部没有任何容量的阻塞队列的线程池，<code>AsyncCall</code>交由线程池之后会开启子线程执行异步请求，然后会执行<code>execute()</code>方法，接着来看<code>Response response = getResponseWithInterceptorChain();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">  <span class="comment">// Build a full stack of interceptors.</span></div><div class="line">  List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">  interceptors.addAll(client.interceptors());</div><div class="line">  interceptors.add(retryAndFollowUpInterceptor);</div><div class="line">  interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache()));</div><div class="line">  interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client));</div><div class="line">  <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">    interceptors.addAll(client.networkInterceptors());</div><div class="line">  &#125;</div><div class="line">  interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket));</div><div class="line"></div><div class="line">  Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, originalRequest);</div><div class="line">  <span class="keyword">return</span> chain.proceed(originalRequest);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到这里创建了一堆拦截器放到了集合里，然后和<code>originalRequest</code>实例一起构建了<code>RealInterceptorChain</code>，最后将执行<code>chain.proceed(originalRequest)</code>的结果返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span></span></div><div class="line">    RealConnection connection) <span class="keyword">throws</span> IOException &#123;</div><div class="line">  <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</div><div class="line"></div><div class="line">  calls++;</div><div class="line"></div><div class="line">   <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">  <span class="comment">// Call the next interceptor in the chain.</span></div><div class="line">  RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(</div><div class="line">      interceptors, streamAllocation, httpCodec, connection, index + <span class="number">1</span>, request);</div><div class="line">  Interceptor interceptor = interceptors.get(index);</div><div class="line">  Response response = interceptor.intercept(next);</div><div class="line"></div><div class="line">   <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">  <span class="keyword">return</span> response;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>proceed</code>方法中又构建了一个<code>RealInterceptorChain</code>实例，<code>index</code>值加 1，接着获取对应 index 位置的<code>Interceptor</code>实例，前面我们可以看到第一个拦截器是<code>retryAndFollowUpInterceptor</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    Request request = chain.request();</div><div class="line"></div><div class="line">    streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">        client.connectionPool(), createAddress(request.url()), callStackTrace);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</div><div class="line">    Response priorResponse = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">      <span class="keyword">if</span> (canceled) &#123;</div><div class="line">        streamAllocation.release();</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Response response = <span class="keyword">null</span>;</div><div class="line">      <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</div><div class="line">      <span class="keyword">try</span> &#123;</div><div class="line">        response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        releaseConnection = <span class="keyword">false</span>;</div><div class="line">      &#125; </div><div class="line">      <span class="comment">//...此处省略部分代码</span></div><div class="line">      <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></div><div class="line">        <span class="keyword">if</span> (releaseConnection) &#123;</div><div class="line">          streamAllocation.streamFailed(<span class="keyword">null</span>);</div><div class="line">          streamAllocation.release();</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></div><div class="line">      <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</div><div class="line">        response = response.newBuilder()</div><div class="line">            .priorResponse(priorResponse.newBuilder()</div><div class="line">                    .body(<span class="keyword">null</span>)</div><div class="line">                    .build())</div><div class="line">            .build();</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      Request followUp = followUpRequest(response);</div><div class="line"></div><div class="line">      <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!forWebSocket) &#123;</div><div class="line">          streamAllocation.release();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> response;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      closeQuietly(response.body());</div><div class="line">	  <span class="comment">//...此处省略部分代码</span></div><div class="line"></div><div class="line">      <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</div><div class="line">        streamAllocation.release();</div><div class="line">        streamAllocation = <span class="keyword">new</span> StreamAllocation(</div><div class="line">            client.connectionPool(), createAddress(followUp.url()), callStackTrace);</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</div><div class="line">            + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      request = followUp;</div><div class="line">      priorResponse = response;</div><div class="line">    &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>这个拦截器功能是根据<code>response</code>来做相应的处理，<code>followUpRequest(response)</code>这个方法里会根据<code>responseCode</code>判断是否需要重新构建<code>Request</code>，默认请求成功的话会返回<code>null</code>，如果发生类似请求重定向之类的，那么便会重新构建<code>Request</code>实例返回，可以看到这里面是一个<code>while (true)</code>循环，那么用重新构建的<code>request</code>再走循环里的逻辑，包括<code>response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);</code>也就是说会再次进行网络请求获取<code>response</code>。那么继续来看<code>proceed</code>，此时的<code>chain</code>是之前创建的<code>index = 1</code>的<code>RealInterceptorChain</code>实例，此时在<code>proceed</code>方法中获取的到的<code>Interceptor</code>是<code>BridgeInterceptor</code>实例，这个拦截器的作用就是把我们构造的请求转换成发送至服务器的请求以及将服务端返回的响应转换成用户友好的响应，这个拦截器的代码就不详细分析了，拦截器这里其实就是运用了责任链模式，每一个拦截器都可以对<code>request</code>和<code>response</code>进行处理，这样的设计是<code>OkHttp</code>比较精妙的一个地方。ok，那么接下来我们再看看缓存拦截器<code>CacheInterceptor</code>里的<code>intercept(Chain chain)</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Response cacheCandidate = cache != <span class="keyword">null</span></div><div class="line">    ? cache.get(chain.request())</div><div class="line">    : <span class="keyword">null</span>;</div></pre></td></tr></table></figure></p>
<p>首先判断<code>cache</code>实例是否为<code>null</code>，如果我们创建<code>OkHttpClient</code>实例时传入了自己的缓存实例的话，会调用<code>get</code>方法，缓存其实是用<code>DiskLruCache</code>形式保存的，key 是以请求<code>url</code>的 md5 值的形式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> now = System.currentTimeMillis();</div><div class="line"></div><div class="line">CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</div><div class="line">Request networkRequest = strategy.networkRequest;</div><div class="line">Response cacheResponse = strategy.cacheResponse;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> CacheStrategy <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">  CacheStrategy candidate = getCandidate();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (candidate.networkRequest != <span class="keyword">null</span> &amp;&amp; request.cacheControl().onlyIfCached()) &#123;</div><div class="line">    <span class="comment">// We're forbidden from using the network and the cache is insufficient.</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> candidate;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这一步是根据请求和缓存<code>Response</code>获取缓存策略，继续看<code>getCandidate()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> CacheStrategy <span class="title">getCandidate</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// No cached response.</span></div><div class="line">  <span class="comment">// 没有缓存</span></div><div class="line">  <span class="keyword">if</span> (cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// Drop the cached response if it's missing a required handshake.</span></div><div class="line">  <span class="comment">// 丢失握手信息</span></div><div class="line">  <span class="keyword">if</span> (request.isHttps() &amp;&amp; cacheResponse.handshake() == <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// 根据返回状态码和 Cache-control 策略判断是否可以缓存</span></div><div class="line">  <span class="comment">// 这里的状态码包括 200（请求成功）404 （服务器找不到请求的网页）等等</span></div><div class="line">  <span class="comment">// Cache-control 判断了 cacheResponse 和 request 中的缓存控制策略是否为no-store</span></div><div class="line">  <span class="keyword">if</span> (!isCacheable(cacheResponse, request)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//根据请求头判断是否是不需要 cache</span></div><div class="line">  CacheControl requestCaching = request.cacheControl();</div><div class="line">  <span class="keyword">if</span> (requestCaching.noCache() || hasConditions(request)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> ageMillis = cacheResponseAge();</div><div class="line">  <span class="keyword">long</span> freshMillis = computeFreshnessLifetime();</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (requestCaching.maxAgeSeconds() != -<span class="number">1</span>) &#123;</div><div class="line">    freshMillis = Math.min(freshMillis, SECONDS.toMillis(requestCaching.maxAgeSeconds()));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> minFreshMillis = <span class="number">0</span>;</div><div class="line">  <span class="keyword">if</span> (requestCaching.minFreshSeconds() != -<span class="number">1</span>) &#123;</div><div class="line">    minFreshMillis = SECONDS.toMillis(requestCaching.minFreshSeconds());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">long</span> maxStaleMillis = <span class="number">0</span>;</div><div class="line">  CacheControl responseCaching = cacheResponse.cacheControl();</div><div class="line">  <span class="keyword">if</span> (!responseCaching.mustRevalidate() &amp;&amp; requestCaching.maxStaleSeconds() != -<span class="number">1</span>) &#123;</div><div class="line">    maxStaleMillis = SECONDS.toMillis(requestCaching.maxStaleSeconds());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!responseCaching.noCache() &amp;&amp; ageMillis + minFreshMillis &lt; freshMillis + maxStaleMillis) &#123;</div><div class="line">    Response.Builder builder = cacheResponse.newBuilder();</div><div class="line">    <span class="keyword">if</span> (ageMillis + minFreshMillis &gt;= freshMillis) &#123;</div><div class="line">      builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"110 HttpURLConnection \"Response is stale\""</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">long</span> oneDayMillis = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span>;</div><div class="line">    <span class="keyword">if</span> (ageMillis &gt; oneDayMillis &amp;&amp; isFreshnessLifetimeHeuristic()) &#123;</div><div class="line">      builder.addHeader(<span class="string">"Warning"</span>, <span class="string">"113 HttpURLConnection \"Heuristic expiration\""</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//这里表示如果缓存没有过期，那么根据 cacheResponse 创建一个 Response</span></div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(<span class="keyword">null</span>, builder.build());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//缓存过期</span></div><div class="line">  String conditionName;</div><div class="line">  String conditionValue;</div><div class="line">  <span class="comment">//如果 etag 不为空，则向网络请求带 If-None-Match</span></div><div class="line">  <span class="keyword">if</span> (etag != <span class="keyword">null</span>) &#123;</div><div class="line">    conditionName = <span class="string">"If-None-Match"</span>;</div><div class="line">    conditionValue = etag;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lastModified != <span class="keyword">null</span>) &#123;</div><div class="line">    conditionName = <span class="string">"If-Modified-Since"</span>;</div><div class="line">    conditionValue = lastModifiedString;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (servedDate != <span class="keyword">null</span>) &#123;</div><div class="line">    conditionName = <span class="string">"If-Modified-Since"</span>;</div><div class="line">    conditionValue = servedDateString;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(request, <span class="keyword">null</span>); <span class="comment">// No condition! Make a regular request.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  Headers.Builder conditionalRequestHeaders = request.headers().newBuilder();</div><div class="line">  Internal.instance.addLenient(conditionalRequestHeaders, conditionName, conditionValue);</div><div class="line"></div><div class="line">  Request conditionalRequest = request.newBuilder()</div><div class="line">      .headers(conditionalRequestHeaders.build())</div><div class="line">      .build();</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CacheStrategy(conditionalRequest, cacheResponse);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来就是根据对<code>CacheStrategy</code>做相应逻辑了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</div><div class="line">      .request(chain.request())</div><div class="line">      .protocol(Protocol.HTTP_1_1)</div><div class="line">      .code(<span class="number">504</span>)</div><div class="line">      .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</div><div class="line">      .body(Util.EMPTY_RESPONSE)</div><div class="line">      .sentRequestAtMillis(-<span class="number">1L</span>)</div><div class="line">      .receivedResponseAtMillis(System.currentTimeMillis())</div><div class="line">      .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里表示如果没有<code>networkRequest</code>并且没有缓存的话，就自己构造一个<code>Response</code> 504 返回<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">return</span> cacheResponse.newBuilder()</div><div class="line">      .cacheResponse(stripBody(cacheResponse))</div><div class="line">      .build();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一步表示如果不进行网络请求那么返回缓存的<code>cacheResponse</code>，接下来如果需要网络就会执行<code>networkResponse = chain.proceed(networkRequest);</code>了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</div><div class="line">    Response response = cacheResponse.newBuilder()</div><div class="line">        .headers(combine(cacheResponse.headers(), networkResponse.headers()))</div><div class="line">        .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</div><div class="line">        .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</div><div class="line">        .cacheResponse(stripBody(cacheResponse))</div><div class="line">        .networkResponse(stripBody(networkResponse))</div><div class="line">        .build();</div><div class="line">    networkResponse.body().close();</div><div class="line"></div><div class="line">    <span class="comment">// Update the cache after combining headers but before stripping the</span></div><div class="line">    <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></div><div class="line">    cache.trackConditionalCacheHit();</div><div class="line">    cache.update(cacheResponse, response);</div><div class="line">    <span class="keyword">return</span> response;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    closeQuietly(cacheResponse.body());</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>拿到网络请求返回的<code>networkResponse</code>后，判断是不是返回 304，如果是的话就把<code>cacheResponse</code>的请求头和<code>networkResponse</code>的请求头合并，然后更新<code>Response</code>缓存，接下来<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">Response response = networkResponse.newBuilder()</div><div class="line">    .cacheResponse(stripBody(cacheResponse))</div><div class="line">    .networkResponse(stripBody(networkResponse))</div><div class="line">    .build();</div><div class="line"></div><div class="line"><span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</div><div class="line">  <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</div><div class="line">    <span class="comment">// Offer this request to the cache.</span></div><div class="line">    CacheRequest cacheRequest = cache.put(response);</div><div class="line">    <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      cache.remove(networkRequest);</div><div class="line">    &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</div><div class="line">      <span class="comment">// The cache cannot be written.</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> response;</div></pre></td></tr></table></figure></p>
<p>接下来根据<code>response</code>里的返回码、method 和内容长度判断是否有需要缓存的 body 内容以及根据<code>response</code>的返回码缓存策略和<code>networkRequest</code>中的缓存策略判断是否需要缓存，如果 body 可以缓存以及策略需要缓存的话，那么会将<code>response</code>存放到<code>cache</code>中。接下来一步是根据网络请求的方式来判断是否需要缓存啦，像类似于”DELETE”、”PUT”之类的请求就没必要添加到缓存里。还有一个<code>CallServerInterceptor</code>就不多讲了，这个拦截器的功能就是向服务器发送请求数据以及获取响应数据。经过这一连串的拦截器处理最后可以获取到<code>Response</code>然后回调返回了～</p>
]]></content>
    
    <summary type="html">
    
      本文是对 OkHttp 原理的简要分析（以异步为例）。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>ConcurrentHashMap原理探析</title>
    <link href="http://yoursite.com/2019/10/17/ConcurrentHashMap%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/17/ConcurrentHashMap原理探析/</id>
    <published>2019-10-17T09:27:13.000Z</published>
    <updated>2019-10-17T12:17:54.324Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashMap</code>在我们的开发中可以说是很常见了，主要是用来存储键值对的数据结构，<code>HashMap</code>并不是线程安全的，如果要想实现线程安全，可以使用<code>Collections.synchronizeMap(hashMap)</code>的方式，当然<code>JDK</code>里也以提供了另外一个可以实现并发操作的键值对存储结构，那就是<code>ConcurrentHashMap</code>，那么接下来我们就来探析下他是如何实现线程安全的，看看<code>put</code>方法的实现机制。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</div><div class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</div><div class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</div><div class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">            tab = initTable();</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</div><div class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</div><div class="line">                <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</div><div class="line">            tab = helpTransfer(tab, f);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            V oldVal = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">synchronized</span> (f) &#123;</div><div class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</div><div class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</div><div class="line">                        binCount = <span class="number">1</span>;</div><div class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class="line">                            K ek;</div><div class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                                ((ek = e.key) == key ||</div><div class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</div><div class="line">                                oldVal = e.val;</div><div class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                    e.val = value;</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                            Node&lt;K,V&gt; pred = e;</div><div class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</div><div class="line">                                                          value, <span class="keyword">null</span>);</div><div class="line">                                <span class="keyword">break</span>;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</div><div class="line">                        Node&lt;K,V&gt; p;</div><div class="line">                        binCount = <span class="number">2</span>;</div><div class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</div><div class="line">                            oldVal = p.val;</div><div class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</div><div class="line">                                p.val = value;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> ReservationNode)</div><div class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Recursive update"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</div><div class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</div><div class="line">                    treeifyBin(tab, i);</div><div class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">return</span> oldVal;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    addCount(<span class="number">1L</span>, binCount);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">spread</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; HASH_BITS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先获取<code>key</code>到<code>hashCode</code>，调用<code>spread</code>方法，将<code>hashCode</code>的高 16 位和低 16 位进行异或操作，再与<code>HASH_BITS</code>进行与操作，<code>HASH_BITS</code>的值是 0x7fffffff，也就是 32 位带符号的最大整数，效果等同于取余，异或主要是为了降低碰撞的几率。接着进入循环之中，首先判断<code>table</code>是否为空，如果为空的话，则进行初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</div><div class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</div><div class="line">            Thread.yield(); <span class="comment">// lost initialization race; just spin</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</div><div class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</div><div class="line">                    table = tab = nt;</div><div class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                sizeCtl = sc;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> tab;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里其实也用到了<code>Unsafe</code>和 CAS 机制，如果不了解可以自行先去看下，因为我们是用无参构造方法创建的对象，那么<code>sizeCtl</code>变量的值就是 0，然后利用 CAS 操作将<code>sizeCtl</code>设置为 -1，此时若有其他线程进入此方法，则会执行<code>Thread.yield();</code>,使当前线程从运行状态变为就绪状态，再回到创建<code>table</code>的线程，创建了一个起始大小为<code>DEFAULT_CAPACITY = 16;</code>长度的<code>Node</code>数组，并设置<code>sizeCtl</code>的值为 12，到此<code>table</code>就创建完成了。再回到循环中，然后通过与数组长度与运算，根据内存地址判断相应位置上的值是否为空，如果为空的话则通过 CAS 机制对在相应地址上进行赋值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> i,</span></span></div><div class="line">                                    Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) &#123;</div><div class="line">    <span class="keyword">return</span> U.compareAndSwapObject(tab, ((<span class="keyword">long</span>)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>赋值成功则跳出当前循环，失败则继续执行循环，即当前的数组上的对应<code>Node</code>已经赋过值，接下来重点看这里<code>synchronized (f)</code>，<code>f</code>是当前数组中的节点，这里也可以看出<code>ConcurrentHashMap</code>是<strong>以数组中的每一个元素作为分段锁的，分段锁的个数即为数组的长度</strong>。<code>if (fh &gt;= 0)</code>判断数组中节点的<code>hash</code>值是否大于 0，是的话表示当前的存储方式还是链表，那么会从链表中找是否有<code>key</code>相同的节点，如果有则替换，没有则加入链表尾部。如果值小于 0（确切的值是 -2）的话，表示当前已经用红黑树存储了，插入<code>TreeBin</code>中。接着判断<code>binCount</code>的值，如果大于<code>TREEIFY_THRESHOLD</code>的值即 8，那么执行<code>treeifyBin(tab, i);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; b; <span class="keyword">int</span> n;</div><div class="line">    <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</div><div class="line">            tryPresize(n &lt;&lt; <span class="number">1</span>);</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">synchronized</span> (b) &#123;</div><div class="line">                <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</div><div class="line">                    TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</div><div class="line">                    <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">                        TreeNode&lt;K,V&gt; p =</div><div class="line">                            <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</div><div class="line">                                              <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">                        <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</div><div class="line">                            hd = p;</div><div class="line">                        <span class="keyword">else</span></div><div class="line">                            tl.next = p;</div><div class="line">                        tl = p;</div><div class="line">                    &#125;</div><div class="line">                    setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先判断<code>tab</code>数组的长度，如果小于<code>MIN_TREEIFY_CAPACITY</code>即 64，那么不会进行红黑树的转换，而是会将数组扩容，否则会将数组<code>index</code>处的链表构建成一个<code>TreeBin</code>，即红黑树实例。</p>
]]></content>
    
    <summary type="html">
    
      对 ConcurrentHashMap 的原理探析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags%C3%9F/Java/"/>
    
  </entry>
  
  <entry>
    <title>ReentrantLock原理探析</title>
    <link href="http://yoursite.com/2019/10/16/ReentrantLock%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/16/ReentrantLock原理探析/</id>
    <published>2019-10-16T07:26:08.000Z</published>
    <updated>2019-10-18T06:41:36.551Z</updated>
    
    <content type="html"><![CDATA[<p>最近在对之前看过的一些源码进行回顾，今天主要是对 ReentrantLock 的源码分析。<br><code>ReentrantLock</code>有两个构造方法，当我们通过无参构造方法创建时，内部会创建的是非公平锁实例，那么本文也以非公平锁的实现机制做分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync = <span class="keyword">new</span> NonfairSync();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>加锁的方法其实很简单，只需要调用<code>lock.lock();</code>就行了，接下来看看这个<code>lock()</code>方法里到底执行了啥<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.lock();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以发现接着调用了<code>NonfairSync</code>实例中的<code>lock()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</div><div class="line">        setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">    <span class="keyword">else</span></div><div class="line">        acquire(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先来看<code>compareAndSetState(0, 1)</code>的逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> U.compareAndSwapInt(<span class="keyword">this</span>, STATE, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个<code>U</code>是<code>Unsafe</code>的实例，那这个类到底是干嘛用的呢，简单来讲，这个类就是用来提供硬件级别的原子操作的，比如通过它你可以获取到某个属性的内存地址。这个地方还牵涉到 CAS(Compare And Swap) 机制，包含三个操作数，内存地址 V， 预期原值 A，新值 B，进行 CAS 操作的时候首先会将内存地址 V 中的值与预期原值 A 比较，如果相同，则将 V 中的值更新为 B，不同则执行相应逻辑，像这里如果 CAS 操作失败的话会返回 false。 <code>STATE</code>是什么呢？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">STATE = U.objectFieldOffset</div><div class="line">                (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</div></pre></td></tr></table></figure></p>
<p>这个变量保存的就是<code>state</code>成员变量的内存地址，这些都定义在<code>NonfairSync</code>的父类<code>AbstractQueuedSynchronizer</code>中，<code>AbstractQueuedSynchronizer</code>是一个基于 FIFO 队列的同步框架，<code>state</code>表示的就是同步状态，如果值为 0 说明没有线程获取锁，反之则说明有线程持有锁。ok，当<code>compareAndSetState(0, 1)</code>返回<code>true</code>时，即表示<code>state</code>之前的值为 0，没有线程持有锁，当前线程获取锁成功，然后执行<code>setExclusiveOwnerThread(Thread.currentThread());</code>把当前线程设置到<code>exclusiveOwnerThread</code>变量中。我们再来看看返回<code>false</code>的情况，执行<code>acquire(1);</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先会调用<code>tryAcquire(arg)</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</div><div class="line">    <span class="keyword">int</span> c = getState();</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</div><div class="line">            setExclusiveOwnerThread(current);</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</div><div class="line">        <span class="keyword">int</span> nextc = c + acquires;</div><div class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</div><div class="line">        setState(nextc);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法是子类<code>NonfairSync</code>来实现的，首先获取<code>state</code>的值，如果是 0，表示之前持有锁的线程已经释放锁了，所以会尝试获取锁，反之不是 0 的话，会先判断当前线程是不是已经持有锁的线程，如果是的话 state 的值继续加 1，这里也说明<code>ReentrantLock</code>是可重入锁。那么我们假如当前线程不是持有锁的线程，所以这个方法最后会返回<code>false</code>，继续执行<code>addWaiter(Node.EXCLUSIVE)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</div><div class="line">    Node node = <span class="keyword">new</span> Node(mode);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        Node oldTail = tail;</div><div class="line">        <span class="keyword">if</span> (oldTail != <span class="keyword">null</span>) &#123;</div><div class="line">            U.putObject(node, Node.PREV, oldTail);</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(oldTail, node)) &#123;</div><div class="line">                oldTail.next = node;</div><div class="line">                <span class="keyword">return</span> node;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            initializeSyncQueue();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先创建一个<code>Node</code>实例，会持有当前线程的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Node(Node nextWaiter) &#123;</div><div class="line">    <span class="keyword">this</span>.nextWaiter = nextWaiter;</div><div class="line">    U.putObject(<span class="keyword">this</span>, THREAD, Thread.currentThread());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>然后是一个<code>for</code>循环，里面会判断尾节点是不是<code>null</code>，如果是<code>null</code>的话，则会初始化队列，并创建一个新的节点，头尾节点都指向它<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initializeSyncQueue</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node h;</div><div class="line">    <span class="keyword">if</span> (U.compareAndSwapObject(<span class="keyword">this</span>, HEAD, <span class="keyword">null</span>, (h = <span class="keyword">new</span> Node())))</div><div class="line">        tail = h;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>继续执行循环中的代码，此时尾节点已经不为<code>null</code>，会把之前持有当前线程节点的前驱指向尾节点，并把这个节点设置成尾节点，原来的尾节点的后驱指向含有当前线程的节点。总结一下就是如果当前没有队列，则创建一个新队列，头节点为没有设置任何值的<code>Node</code>，尾节点为包含当前线程的<code>Node</code>；如果已经有队列的话，则会把创建的含有当前线程的节点放入队列的尾部。当创建的<code>Node</code>放入队列之后，我们再来看看<code>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        cancelAcquire(node);</div><div class="line">        <span class="keyword">throw</span> t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>循环中首先获取当前节点的前驱节点，判断前驱节点是否为头节点，如果是，执行<code>tryAcquire(arg)</code>方法，尝试获取锁，这里假设仍有其它线程持有锁，那么会执行第二个 if 判断，<code>shouldParkAfterFailedAcquire(p, node)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * This node has already set status asking a release</div><div class="line">         * to signal it, so it can safely park.</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * Predecessor was cancelled. Skip over predecessors and</div><div class="line">         * indicate retry.</div><div class="line">         */</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class="line">         * need a signal, but don't park yet.  Caller will need to</div><div class="line">         * retry to make sure it cannot acquire before parking.</div><div class="line">         */</div><div class="line">        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个方法用来判断前驱<code>Node</code>的<code>waitStatus</code>，这里会把前驱节点的<code>waitStatus</code>设置成<code>Node.SIGNAL</code>，即等待获取锁的状态，设置成功会返回<code>true</code>，继续执行<code>parkAndCheckInterrupt()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</div><div class="line">    LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> Thread.interrupted();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>线程到这里就被阻塞了。<br><code>lock.unlock();</code>方法的执行流程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</div><div class="line">    sync.release(<span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>来看看<code>Sync</code>中<code>tryRelease(arg)</code>的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> c = getState() - releases;</div><div class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</div><div class="line">        free = <span class="keyword">true</span>;</div><div class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    setState(c);</div><div class="line">    <span class="keyword">return</span> free;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先判断<code>c</code>的值是否为 0，如果不为 0，则表示返回<code>false</code>，执行结束，这里也说明了如果之前<code>lock()</code>方法被多次调用，那么<code>unlock();</code>也应该的调用相等次数才会尝试释放锁，ok，那么假设这里之前只调用了一次<code>lock()</code>方法，c 的值为 0，获取到<code>head</code>节点，如果头节点不为空，并且<code>waitStatus</code>不等于 0，执行<code>unparkSuccessor(h);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line">     * If status is negative (i.e., possibly needing signal) try</div><div class="line">     * to clear in anticipation of signalling.  It is OK if this</div><div class="line">     * fails or if status is changed by waiting thread.</div><div class="line">     */</div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        node.compareAndSetWaitStatus(ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line">     * Thread to unpark is held in successor, which is normally</div><div class="line">     * just the next node.  But if cancelled or apparently null,</div><div class="line">     * traverse backwards from tail to find the actual</div><div class="line">     * non-cancelled successor.</div><div class="line">     */</div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node p = tail; p != node &amp;&amp; p != <span class="keyword">null</span>; p = p.prev)</div><div class="line">            <span class="keyword">if</span> (p.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们把头节点作为参数传入方法中，首先判断<code>waitStatus</code>的值，之前我们设置过的等待获取锁的状态的值为<code>-1</code>是小于 0 的，然后把头节点的<code>waitStatus</code>的值通过 CAS 值设置为 0，获取头节点的后驱节点，即刚才我们为获取到锁的子线程节点，最后刚才阻塞的节点被唤醒，我们会到刚才阻塞住的地方<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</div><div class="line">        cancelAcquire(node);</div><div class="line">        <span class="keyword">throw</span> t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>唤醒之后会继续执行<code>for</code>循环里的逻辑，如果当前节点的前驱节点是节点，然后调用<code>tryAcquire(arg)</code>方法就可以获取到锁了，<code>setHead(node);</code>会把当前节点里面的前驱节点变量和当前持有线程的变量设置为<code>null</code>，当前节点会变成<code>head</code>节点。</p>
<p>非公平锁的逻辑大致就是如此了，<code>ReentrantLock</code>里不是还有个公平锁<code>FairSync</code>么，区别就在与非公平锁调用<code>lock()</code>就会执行<code>compareAndSetState(0, 1)</code>尝试获取锁，而公平锁<code>FairSync</code>则会判断当前是否有线程持有锁，没有的话还会判断当前队列是否存在等待获取锁的节点，有的话会把当前线程的<code>Node</code>放入队尾，一开始并不会去尝试获取锁。</p>
]]></content>
    
    <summary type="html">
    
      对 ReentrantLock 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>RxJava原理探析</title>
    <link href="http://yoursite.com/2019/10/15/RxJava%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/15/RxJava原理探析/</id>
    <published>2019-10-15T03:43:55.000Z</published>
    <updated>2019-10-16T02:15:19.989Z</updated>
    
    <content type="html"><![CDATA[<p>先来看如何创建<code>Observable</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.create(<span class="keyword">new</span> ObservableOnSubscribe() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObservableEmitter e)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		e.onNext(<span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>通过调用<code>Observable</code>中的<code>create</code>静态方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(ObservableOnSubscribe&lt;T&gt; source)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(source, <span class="string">"source is null"</span>);</div><div class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableCreate&lt;T&gt;(source));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终返回的是一个<code>ObservableCreate</code>实例，它关联了一个我们创建的<code>ObservableOnSubscribe</code>实例，<code>ObservableCreate</code>是<code>Observable</code>的子类。<br>接着创建<code>Observer</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observer observer = <span class="keyword">new</span> Observer() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>接下来调用<code>observable.subscribe(observer);</code>，我们来看看<code>subscribe</code>方法中做了什么<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(observer, <span class="string">"observer is null"</span>);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        observer = RxJavaPlugins.onSubscribe(<span class="keyword">this</span>, observer);</div><div class="line"></div><div class="line">        ObjectHelper.requireNonNull(observer, <span class="string">"Plugin returned null Observer"</span>);</div><div class="line"></div><div class="line">        subscribeActual(observer);</div><div class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123; <span class="comment">// NOPMD</span></div><div class="line">        <span class="keyword">throw</span> e;</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        Exceptions.throwIfFatal(e);</div><div class="line">        <span class="comment">// can't call onError because no way to know if a Disposable has been set or not</span></div><div class="line">        <span class="comment">// can't call onSubscribe because the call might have set a Subscription already</span></div><div class="line">        RxJavaPlugins.onError(e);</div><div class="line"></div><div class="line">        NullPointerException npe = <span class="keyword">new</span> NullPointerException(<span class="string">"Actually not, but can't throw other exceptions due to RS"</span>);</div><div class="line">        npe.initCause(e);</div><div class="line">        <span class="keyword">throw</span> npe;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要的就是<code>subscribeActual(observer);</code>这一步，它的实现在<code>ObservableCreate</code>类中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">       CreateEmitter&lt;T&gt; parent = <span class="keyword">new</span> CreateEmitter&lt;T&gt;(observer);</div><div class="line">       observer.onSubscribe(parent);</div><div class="line"></div><div class="line">       <span class="keyword">try</span> &#123;</div><div class="line">           source.subscribe(parent);</div><div class="line">       &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">           Exceptions.throwIfFatal(ex);</div><div class="line">           parent.onError(ex);</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到这个方法里首先创建了一个<code>CreateEmitter</code>实例，并把<code>observer</code>关联起来，然后调用<code>observer.onSubscribe(parent);</code>，即执行了我们开始创建<code>Observer</code>时候实现的<code>onSubscribe(Disposable d)</code>方法，并把<code>CreateEmitter</code>实例传递进去。这个<code>CreateEmitter</code>实现了<code>Disposable</code>接口。接下来执行<code>source.subscribe(parent);</code>即调用我们一开始创建<code>obervable</code>实例时 new 的<code>ObservableOnSubscribe</code>实例的<code>subscribe</code>方法，此时执行<code>e.onNext(1);</code>，即<code>CreateEmitter</code>中的<code>onNext</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">        onError(<span class="keyword">new</span> NullPointerException(<span class="string">"onNext called with null. Null values are generally not allowed in 2.x operators and sources."</span>));</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!isDisposed()) &#123;</div><div class="line">        observer.onNext(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到最后还是调用了<code>observer.onNext(t);</code>。<br>接下来看看 RxJava 是如何进行线程切换的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">observable</div><div class="line">   .subscribeOn(Schedulers.io())</div><div class="line">   .observeOn(AndroidSchedulers.mainThread())</div><div class="line">   .subscribe(observer);</div></pre></td></tr></table></figure></p>
<p>这里添加了两行代码，<code>Schedulers.io()</code>返回是一个<code>IoScheduler</code>实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</div><div class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>即把当前的<code>Observable</code>和<code>IoScheduler</code>实例关联到新创建的<code>ObservableSubscribeOn</code>实例中去，最后返回这个实例，这个类也是继承于<code>Observable</code>的。此时如果调用<code>.subscribe(observer)</code>，那么会走到这里<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; s)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnObserver&lt;T&gt;(s);</div><div class="line"></div><div class="line">    s.onSubscribe(parent);</div><div class="line"></div><div class="line">    parent.setDisposable(scheduler.scheduleDirect(<span class="keyword">new</span> SubscribeTask(parent)));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>和之前类似，先是把<code>Observer</code>实例关联到新创建的<code>SubscribeOnObserver</code>实例中，然后调用<code>Observer</code>实例的<code>onSubscribe</code>方法，然后创建一个<code>SubscribeTask</code>实例，关联实例<code>parent</code>，这个<code>SubscribeTask</code>是一个实现了<code>Runnable</code>接口的类，<code>run()</code>中执行了<code>source.subscribe(parent);</code>这时就大概可以猜到它会放到一个子线程里去执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscribeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscribeOnObserver&lt;T&gt; parent;</div><div class="line"></div><div class="line">    SubscribeTask(SubscribeOnObserver&lt;T&gt; parent) &#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        source.subscribe(parent);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着看<code>scheduler.scheduleDirect(new SubscribeTask(parent))</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">scheduleDirect</span><span class="params">(@NonNull Runnable run, <span class="keyword">long</span> delay, @NonNull TimeUnit unit)</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> Worker w = createWorker();</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</div><div class="line"></div><div class="line">    DisposeTask task = <span class="keyword">new</span> DisposeTask(decoratedRun, w);</div><div class="line"></div><div class="line">    w.schedule(task, delay, unit);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> task;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来看<code>IoScheduler</code>中<code>createWorker()</code>是怎么实现的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventLoopWorker(pool.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>pool.get()</code>是获取<code>CachedWorkerPool</code>实例，是个实例在<code>IoScheduler</code>实例初始化的时候被创建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">    CachedWorkerPool update = <span class="keyword">new</span> CachedWorkerPool(KEEP_ALIVE_TIME, KEEP_ALIVE_UNIT, threadFactory);</div><div class="line">    <span class="keyword">if</span> (!pool.compareAndSet(NONE, update)) &#123;</div><div class="line">        update.shutdown();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>CachedWorkerPool</code>顾名思义就是<code>ThreadWorker</code>的缓存池，用<code>ConcurrentLinkedQueue</code>保存，接着<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompositeDisposable tasks;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CachedWorkerPool pool;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadWorker threadWorker;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> AtomicBoolean once = <span class="keyword">new</span> AtomicBoolean();</div><div class="line"></div><div class="line">    EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class="line">        <span class="keyword">this</span>.pool = pool;</div><div class="line">        <span class="keyword">this</span>.tasks = <span class="keyword">new</span> CompositeDisposable();</div><div class="line">        <span class="keyword">this</span>.threadWorker = pool.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispose</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (once.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</div><div class="line">            tasks.dispose();</div><div class="line"></div><div class="line">            <span class="comment">// releasing the pool should be the last action</span></div><div class="line">            pool.release(threadWorker);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDisposed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> once.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@NonNull</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable action, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (tasks.isDisposed()) &#123;</div><div class="line">            <span class="comment">// don't schedule, we are unsubscribed</span></div><div class="line">            <span class="keyword">return</span> EmptyDisposable.INSTANCE;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>构造方法里调用了<code>pool.get()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function">ThreadWorker <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (allWorkers.isDisposed()) &#123;</div><div class="line">        <span class="keyword">return</span> SHUTDOWN_THREAD_WORKER;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (!expiringWorkerQueue.isEmpty()) &#123;</div><div class="line">        ThreadWorker threadWorker = expiringWorkerQueue.poll();</div><div class="line">        <span class="keyword">if</span> (threadWorker != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">return</span> threadWorker;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// No cached worker found, so create a new one.</span></div><div class="line">    ThreadWorker w = <span class="keyword">new</span> ThreadWorker(threadFactory);</div><div class="line">    allWorkers.add(w);</div><div class="line">    <span class="keyword">return</span> w;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一步其实就是判断缓存队列是不是空的，如果不是，就从中取出一个，否则就创建一个并 add 到<code>allWorkers</code>中。<br>ok，<code>createWorker()</code>这一步终于走完了，接着创建<code>DisposeTask</code>实例并把之前的<code>Worker</code>和<code>Runnable</code>实例关联进去，下一步执行<code>w.schedule(task, delay, unit);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Disposable <span class="title">schedule</span><span class="params">(@NonNull Runnable action, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tasks.isDisposed()) &#123;</div><div class="line">        <span class="comment">// don't schedule, we are unsubscribed</span></div><div class="line">        <span class="keyword">return</span> EmptyDisposable.INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> threadWorker.scheduleActual(action, delayTime, unit, tasks);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用之前获取到的<code>ThreadWorker</code>实例调用<code>scheduleActual</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@NonNull</span></div><div class="line"><span class="function"><span class="keyword">public</span> ScheduledRunnable <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Runnable run, <span class="keyword">long</span> delayTime, @NonNull TimeUnit unit, @Nullable DisposableContainer parent)</span> </span>&#123;</div><div class="line">    Runnable decoratedRun = RxJavaPlugins.onSchedule(run);</div><div class="line"></div><div class="line">    ScheduledRunnable sr = <span class="keyword">new</span> ScheduledRunnable(decoratedRun, parent);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!parent.add(sr)) &#123;</div><div class="line">            <span class="keyword">return</span> sr;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    Future&lt;?&gt; f;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</div><div class="line">            f = executor.submit((Callable&lt;Object&gt;)sr);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            f = executor.schedule((Callable&lt;Object&gt;)sr, delayTime, unit);</div><div class="line">        &#125;</div><div class="line">        sr.setFuture(f);</div><div class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ex) &#123;</div><div class="line">        <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">            parent.remove(sr);</div><div class="line">        &#125;</div><div class="line">        RxJavaPlugins.onError(ex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> sr;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到，最终提交到<code>executor</code>线程池中执行，最终才会执行<code>source.subscribe(parent);</code><br><code>subscribeOn(Schedulers.io())</code>分析完，接下来看<code>observeOn(AndroidSchedulers.mainThread())</code>是如何执行的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHolder</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Scheduler DEFAULT = <span class="keyword">new</span> HandlerScheduler(<span class="keyword">new</span> Handler(Looper.getMainLooper()));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CheckReturnValue</span></div><div class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CheckReturnValue</span></div><div class="line"><span class="meta">@SchedulerSupport</span>(SchedulerSupport.CUSTOM)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</div><div class="line">    ObjectHelper.requireNonNull(scheduler, <span class="string">"scheduler is null"</span>);</div><div class="line">    ObjectHelper.verifyPositive(bufferSize, <span class="string">"bufferSize"</span>);</div><div class="line">    <span class="keyword">return</span> RxJavaPlugins.onAssembly(<span class="keyword">new</span> ObservableObserveOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, delayError, bufferSize));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里创建了一个<code>ObservableObserveOn</code>实例，继续来看<code>subscribeActual(Observer&lt;? super T&gt; observer)</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">subscribeActual</span><span class="params">(Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</div><div class="line">        source.subscribe(observer);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Scheduler.Worker w = scheduler.createWorker();</div><div class="line"></div><div class="line">        source.subscribe(<span class="keyword">new</span> ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>scheduler.createWorker();</code>这里返回的是从<code>HandlerScheduler</code>里创建的<code>HandlerWorker(handler)</code>，这个<code>handler</code>是与主线程的<code>looper</code>绑定的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HandlerWorker(handler);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接着调用<code>source.subscribe</code>，<code>source</code>就是我们调用<code>.subscribeOn(Schedulers.io())</code>返回的<code>ObservableSubscribeOn</code>实例，回到上面讲过的调用流程了。接下来如果执行<code>e.onNext(1);</code>那么就是调用<code>ObserveOnObserver</code>实例中的<code>onNext</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (done) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (sourceMode != QueueDisposable.ASYNC) &#123;</div><div class="line">        queue.offer(t);</div><div class="line">    &#125;</div><div class="line">    schedule();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行<code>schedule();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (getAndIncrement() == <span class="number">0</span>) &#123;</div><div class="line">        worker.schedule(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最终会执行如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function">ublic Disposable <span class="title">schedule</span><span class="params">(Runnable run, <span class="keyword">long</span> delay, TimeUnit unit)</span> </span>&#123;</div><div class="line">   <span class="keyword">if</span> (run == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"run == null"</span>);</div><div class="line">   <span class="keyword">if</span> (unit == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"unit == null"</span>);</div><div class="line"></div><div class="line">   <span class="keyword">if</span> (disposed) &#123;</div><div class="line">       <span class="keyword">return</span> Disposables.disposed();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   run = RxJavaPlugins.onSchedule(run);</div><div class="line"></div><div class="line">   ScheduledRunnable scheduled = <span class="keyword">new</span> ScheduledRunnable(handler, run);</div><div class="line"></div><div class="line">   Message message = Message.obtain(handler, scheduled);</div><div class="line">   message.obj = <span class="keyword">this</span>; <span class="comment">// Used as token for batch disposal of this worker's runnables.</span></div><div class="line"></div><div class="line">   handler.sendMessageDelayed(message, Math.max(<span class="number">0L</span>, unit.toMillis(delay)));</div><div class="line"></div><div class="line">   <span class="comment">// Re-check disposed state for removing in case we were racing a call to dispose().</span></div><div class="line">   <span class="keyword">if</span> (disposed) &#123;</div><div class="line">       handler.removeCallbacks(scheduled);</div><div class="line">       <span class="keyword">return</span> Disposables.disposed();</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="keyword">return</span> scheduled;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>因为我们之前讲过<code>handler</code>是绑定主线程的，然后就会在主线程中执行<code>run()</code> 方法，线程切换就在这里完成，接着执行<code>ObserveOnObserver</code>中的<code>run()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (outputFused) &#123;</div><div class="line">        drainFused();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        drainNormal();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来会走<code>drainNormal();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">drainNormal</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> missed = <span class="number">1</span>;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> SimpleQueue&lt;T&gt; q = queue;</div><div class="line">    <span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; a = actual;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="keyword">if</span> (checkTerminated(done, q.isEmpty(), a)) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">boolean</span> d = done;</div><div class="line">            T v;</div><div class="line"></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                v = q.poll();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                Exceptions.throwIfFatal(ex);</div><div class="line">                s.dispose();</div><div class="line">                q.clear();</div><div class="line">                a.onError(ex);</div><div class="line">                worker.dispose();</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (checkTerminated(d, empty, a)) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (empty) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            a.onNext(v);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        missed = addAndGet(-missed);</div><div class="line">        <span class="keyword">if</span> (missed == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里就是从队列中取出消息，然后调用<code>onNext</code>方法。<br>总结：RxJava 的优点在于链式调用，逻辑非常清楚，切换线程也十分方便，也可以随时中断流程。</p>
]]></content>
    
    <summary type="html">
    
      对 RxJava 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>AsyncTask原理探析</title>
    <link href="http://yoursite.com/2019/10/13/AsyncTask%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/13/AsyncTask原理探析/</id>
    <published>2019-10-13T11:17:12.000Z</published>
    <updated>2019-10-15T01:22:18.104Z</updated>
    
    <content type="html"><![CDATA[<p><code>AsyncTask</code>是一个在安卓开发中帮助开发者更简便地创建异步任务的类。先来看简单看一下其用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> AsyncTask&lt;String,Integer,String&gt;()&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPreExecute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onPostExecute(s);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... strings)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;.execute(<span class="string">"https://cn.bing.com/"</span>);</div></pre></td></tr></table></figure></p>
<p>首先我们来看三个类型参数，第一个<code>Params</code>表示执行任务时传入参数类型，第二个<code>Progress</code>表示后台执行任务更新的进度类型，第三个<code>Result</code>表示后台任务执行结束返回结构的类型。<br>接下来我们来分析下<code>AsyncTask</code>初始化做了些什么。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">AsyncTask</span><span class="params">(@Nullable Looper callbackLooper)</span> </span>&#123;</div><div class="line">    mHandler = callbackLooper == <span class="keyword">null</span> || callbackLooper == Looper.getMainLooper()</div><div class="line">        ? getMainHandler()</div><div class="line">        : <span class="keyword">new</span> Handler(callbackLooper);</div><div class="line"></div><div class="line">    mWorker = <span class="keyword">new</span> WorkerRunnable&lt;Params, Result&gt;() &#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">            mTaskInvoked.set(<span class="keyword">true</span>);</div><div class="line">            Result result = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</div><div class="line">                <span class="comment">//noinspection unchecked</span></div><div class="line">                result = doInBackground(mParams);</div><div class="line">                Binder.flushPendingCommands();</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable tr) &#123;</div><div class="line">                mCancelled.set(<span class="keyword">true</span>);</div><div class="line">                <span class="keyword">throw</span> tr;</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                postResult(result);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> result;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    mFuture = <span class="keyword">new</span> FutureTask&lt;Result&gt;(mWorker) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                postResultIfNotInvoked(get());</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                android.util.Log.w(LOG_TAG, e);</div><div class="line">            &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"An error occurred while executing doInBackground()"</span>,</div><div class="line">                        e.getCause());</div><div class="line">            &#125; <span class="keyword">catch</span> (CancellationException e) &#123;</div><div class="line">                postResultIfNotInvoked(<span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>主要做了三件事，第一创建<code>InternalHandler</code>类型的对象，这个<code>Handler</code>与主线程的<code>looper</code>绑定；第二创建<code>mWorker</code>对象，<code>WorkerRunnable</code>是一个<code>implements</code>了<code>Callable</code>接口的抽象类，这个<code>Callable</code>接口里定义了一个<code>call()</code>方法，可以看到这个重写的<code>call()</code>方法主要执行的就是异步操作，<code>doInBackground(mParams);</code>就在这里被调用；第三步创建<code>FutureTask</code>对象，<code>FutureTask</code>封装了<code>WorkerRunnable</code>中的<code>call()</code>方法。<br>以调用<code>execute()</code>入口，最后调用的是<code>executeOnExecutor()</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> AsyncTask&lt;Params, Progress, Result&gt; <span class="title">executeOnExecutor</span><span class="params">(Executor exec,</span></span></div><div class="line">        Params... params) &#123;</div><div class="line">    <span class="keyword">if</span> (mStatus != Status.PENDING) &#123;</div><div class="line">        <span class="keyword">switch</span> (mStatus) &#123;</div><div class="line">            <span class="keyword">case</span> RUNNING:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task is already running."</span>);</div><div class="line">            <span class="keyword">case</span> FINISHED:</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot execute task:"</span></div><div class="line">                        + <span class="string">" the task has already been executed "</span></div><div class="line">                        + <span class="string">"(a task can be executed only once)"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    mStatus = Status.RUNNING;</div><div class="line"></div><div class="line">    onPreExecute();</div><div class="line"></div><div class="line">    mWorker.mParams = params;</div><div class="line">    exec.execute(mFuture);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第一步会判断当前的任务执行状态，如果是正在执行中或者已经执行结束，那么会抛出异常，所以创建的<code>AsyncTask</code>无法多次执行<code>executed()</code>，如果是等待执行状态，那么将状态改为执行中；第二步执行<code>onPreExecute();</code>，也就是我们执行异步任务之前做的准备，这个方法在我们创建异步任务时可以重写添加自己的处理逻辑；第三步将传入的参数赋值给<code>mWorker</code>中的变量；第四步<code>exec.execute(mFuture);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> ArrayDeque&lt;Runnable&gt; mTasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</div><div class="line">    Runnable mActive;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</div><div class="line">        mTasks.offer(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    r.run();</div><div class="line">                &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                    scheduleNext();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        <span class="keyword">if</span> (mActive == <span class="keyword">null</span>) &#123;</div><div class="line">            scheduleNext();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">            THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>exec</code>是<code>SerialExecutor</code>的实例，是<code>AsyncTask</code>中的静态变量，类加载的时候被初始化，被所有实例所共有，它其实是一个双端队列，保存着待执行的任务。ok，<code>mFuture</code>加入队列之后，如果没有正在执行的任务，即调用<code>scheduleNext();</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> ((mActive = mTasks.poll()) != <span class="keyword">null</span>) &#123;</div><div class="line">        THREAD_POOL_EXECUTOR.execute(mActive);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>THREAD_POOL_EXECUTOR</code>是静态代码块创建的一个线程池，这里就是把任务从队列中取出交给线程池执行，最终会调用<code>mWorker</code>的<code>call()</code>方法，<code>doInBackground()</code>执行完返回一个结果最终调用<code>postResult(result);</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Result <span class="title">postResult</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,</div><div class="line">            <span class="keyword">new</span> AsyncTaskResult&lt;Result&gt;(<span class="keyword">this</span>, result));</div><div class="line">    message.sendToTarget();</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>getHandler()</code>获取到的是<code>InternalHandler</code>实例，接着看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InternalHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>(looper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>, <span class="string">"RawUseOfParameterizedType"</span>&#125;)</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;</div><div class="line">        <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_RESULT:</div><div class="line">                <span class="comment">// There is only one result</span></div><div class="line">                result.mTask.finish(result.mData[<span class="number">0</span>]);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            <span class="keyword">case</span> MESSAGE_POST_PROGRESS:</div><div class="line">                result.mTask.onProgressUpdate(result.mData);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着调用<code>AsyncTask</code>中的<code>finish(result.mData[0]);</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">(Result result)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (isCancelled()) &#123;</div><div class="line">        onCancelled(result);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        onPostExecute(result);</div><div class="line">    &#125;</div><div class="line">    mStatus = Status.FINISHED;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>最后调用<code>onPostExecute(result);</code>返回执行结果。<br>我始终还想不明白 Google 工程师设计成串行的目的是为了什么？？？</p>
]]></content>
    
    <summary type="html">
    
      对 AsyncTask 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>HandlerThread原理探析</title>
    <link href="http://yoursite.com/2019/10/12/HandlerThread%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/12/HandlerThread原理探析/</id>
    <published>2019-10-12T11:01:50.000Z</published>
    <updated>2019-10-13T02:23:33.721Z</updated>
    
    <content type="html"><![CDATA[<p><code>HandlerThread</code>是一个可以执行多个异步操作，而不需要创建多线程的类。<code>HandlerThread</code>继承于<code>Thread</code>，是<code>Thread</code>的子类。</p>
<p>如何使用<code>HandlerThread</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> Handler myHandler;</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startHandlerThread</span><span class="params">()</span> </span>&#123;</div><div class="line">    HandlerThread handlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"handlerThread"</span>);</div><div class="line">    handlerThread.start();</div><div class="line">    myHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper()) &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            <span class="comment">//执行耗时操作</span></div><div class="line">            <span class="keyword">switch</span> (msg.what) &#123;</div><div class="line">                <span class="keyword">default</span>:</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们要执行某一个耗时操作，就只需要通过<code>myHandler</code>调用<code>sendMessage()</code>方法可以了。<br>那么他是如何实现的呢？首先我们要知道它是一个继承于<code>Thread</code>的类，那么当调用<code>start()</code>方法时就会开启线程，然后执行<code>run()</code>方法，接下来看这个方法是如何被重写的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    mTid = Process.myTid();</div><div class="line">    Looper.prepare();</div><div class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</div><div class="line">        mLooper = Looper.myLooper();</div><div class="line">        notifyAll();</div><div class="line">    &#125;</div><div class="line">    Process.setThreadPriority(mPriority);</div><div class="line">    onLooperPrepared();</div><div class="line">    Looper.loop();</div><div class="line">    mTid = -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实就是在子线程里创建一个<code>Looper</code>对象，然后调用<code>loop()</code>方法循环获取消息，那么为什么<code>handleMessage(Message msg)</code>会在子线程里执行呢，我们可以看到其实在构建<code>Handler</code>的时候通过<code>handlerThread.getLooper()</code>将子线程的<code>looper</code>传入了，理所当然<code>loop()</code>中<code>msg.target.dispatchMessage(msg);</code>也会在子线程中执行。</p>
<p>其实在<code>IntentService</code>内部就是用了<code>HandlerThread</code>来实现的，不妨来看看它的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Looper mServiceLooper;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ServiceHandler mServiceHandler;</div><div class="line">    <span class="keyword">private</span> String mName;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mRedelivery;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ServiceHandler</span><span class="params">(Looper looper)</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>(looper);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">            onHandleIntent((Intent)msg.obj);</div><div class="line">            stopSelf(msg.arg1);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Creates an IntentService.  Invoked by your subclass's constructor.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> name Used to name the worker thread, important only for debugging.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentService</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>();</div><div class="line">        mName = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Sets intent redelivery preferences.  Usually called from the constructor</div><div class="line">     * with your preferred semantics.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;If enabled is true,</div><div class="line">     * &#123;<span class="doctag">@link</span> #onStartCommand(Intent, int, int)&#125; will return</div><div class="line">     * &#123;<span class="doctag">@link</span> Service#START_REDELIVER_INTENT&#125;, so if this process dies before</div><div class="line">     * &#123;<span class="doctag">@link</span> #onHandleIntent(Intent)&#125; returns, the process will be restarted</div><div class="line">     * and the intent redelivered.  If multiple Intents have been sent, only</div><div class="line">     * the most recent one is guaranteed to be redelivered.</div><div class="line">     *</div><div class="line">     * &lt;p&gt;If enabled is false (the default),</div><div class="line">     * &#123;<span class="doctag">@link</span> #onStartCommand(Intent, int, int)&#125; will return</div><div class="line">     * &#123;<span class="doctag">@link</span> Service#START_NOT_STICKY&#125;, and if the process dies, the Intent</div><div class="line">     * dies along with it.</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntentRedelivery</span><span class="params">(<span class="keyword">boolean</span> enabled)</span> </span>&#123;</div><div class="line">        mRedelivery = enabled;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">TODO:</span> It would be nice to have an option to hold a partial wakelock</span></div><div class="line">        <span class="comment">// during processing, and to have a static startService(Context, Intent)</span></div><div class="line">        <span class="comment">// method that would launch the service &amp; hand off a wakelock.</span></div><div class="line"></div><div class="line">        <span class="keyword">super</span>.onCreate();</div><div class="line">        HandlerThread thread = <span class="keyword">new</span> HandlerThread(<span class="string">"IntentService["</span> + mName + <span class="string">"]"</span>);</div><div class="line">        thread.start();</div><div class="line"></div><div class="line">        mServiceLooper = thread.getLooper();</div><div class="line">        mServiceHandler = <span class="keyword">new</span> ServiceHandler(mServiceLooper);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        Message msg = mServiceHandler.obtainMessage();</div><div class="line">        msg.arg1 = startId;</div><div class="line">        msg.obj = intent;</div><div class="line">        mServiceHandler.sendMessage(msg);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * You should not override this method for your IntentService. Instead,</div><div class="line">     * override &#123;<span class="doctag">@link</span> #onHandleIntent&#125;, which the system calls when the IntentService</div><div class="line">     * receives a start request.</div><div class="line">     * <span class="doctag">@see</span> android.app.Service#onStartCommand</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(@Nullable Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">        onStart(intent, startId);</div><div class="line">        <span class="keyword">return</span> mRedelivery ? START_REDELIVER_INTENT : START_NOT_STICKY;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">        mServiceLooper.quit();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Unless you provide binding for your service, you don't need to implement this</div><div class="line">     * method, because the default implementation returns null.</div><div class="line">     * <span class="doctag">@see</span> android.app.Service#onBind</div><div class="line">     */</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="meta">@Nullable</span></div><div class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * This method is invoked on the worker thread with a request to process.</div><div class="line">     * Only one Intent is processed at a time, but the processing happens on a</div><div class="line">     * worker thread that runs independently from other application logic.</div><div class="line">     * So, if this code takes a long time, it will hold up other requests to</div><div class="line">     * the same IntentService, but it will not hold up anything else.</div><div class="line">     * When all requests have been handled, the IntentService stops itself,</div><div class="line">     * so you should not call &#123;<span class="doctag">@link</span> #stopSelf&#125;.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@param</span> intent The value passed to &#123;<span class="doctag">@link</span></div><div class="line">     *               android.content.Context#startService(Intent)&#125;.</div><div class="line">     *               This may be null if the service is being restarted after</div><div class="line">     *               its process has gone away; see</div><div class="line">     *               &#123;<span class="doctag">@link</span> android.app.Service#onStartCommand&#125;</div><div class="line">     *               for details.</div><div class="line">     */</div><div class="line">    <span class="meta">@WorkerThread</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onHandleIntent</span><span class="params">(@Nullable Intent intent)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们可以看到在<code>onCreate()</code>方法里创建了一个命名为<code>thread</code>的<code>HandlerThread</code>实例，同时也创建了一个<code>ServiceHandler</code>的实例，并将从<code>thread</code>里获取到的<code>looper</code>作为初始化参数传入，在<code>onStart()</code>方法中调用了<code>mServiceHandler.sendMessage(msg);</code>，再看<code>ServiceHandler</code>中的<code>handleMessage(Message msg)</code>方法中调用了<code>onHandleIntent((Intent)msg.obj);</code>，即我们要实现的抽象方法，该方法在子线程中执行。</p>
<p><code>HanderThread</code>的优点在于我们可以不用重复创建线程执行异步操作，缺点也很明显，就是它是队列的形式执行异步任务。</p>
]]></content>
    
    <summary type="html">
    
      对 HandlerThread 原理的简要分析。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://yoursite.com/2018/08/11/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/11/Java反射机制/</id>
    <published>2018-08-11T13:53:45.000Z</published>
    <updated>2019-10-26T02:08:16.252Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><blockquote>
<p>Reflection is a feature in the Java programming language. It allows an executing Java program to examine or “introspect” upon itself, and manipulate internal properties of the program. For example, it’s possible for a Java class to obtain the names of all its members and display them. — <a href="https://www.oracle.com/technetwork/articles/java/javareflection-1536171.html" target="_blank" rel="external">from oracle</a></p>
</blockquote>
<p>大致意思是反射是 Java 语言的特性之一，它允许一个运行中的 Java 程序去获取自身的信息并操作它们。</p>
<p>首先我们定义一个 Student 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">protected</span> String name;</div><div class="line">	<span class="keyword">public</span> String gender;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, String gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>获取 Class 对象有如下三种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class clsA = Class.forName(<span class="string">"com.djp.demo.Student"</span>);</div><div class="line">Class clsB = Student.class;</div><div class="line">Class clsC = <span class="keyword">new</span> Student().getClass();</div></pre></td></tr></table></figure></p>
<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethods</span><span class="params">(Class cls)</span> </span>&#123;</div><div class="line">	Method[] methods = cls.getDeclaredMethods();</div><div class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">		System.out.println(method.toString());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>getDeclaredMethods()</code>方法可以返回类或者接口的所有方法，包括 public, protected, defalut, and private，但无法获取到继承的方法。打印信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public java.lang.String com.djp.demo.Student.getName()</div><div class="line">public void com.djp.demo.Student.setName(java.lang.String)</div><div class="line">public int com.djp.demo.Student.getAge()</div><div class="line">public java.lang.String com.djp.demo.Student.getGender()</div><div class="line">public void com.djp.demo.Student.setGender(java.lang.String)</div><div class="line">public void com.djp.demo.Student.setAge(int)</div></pre></td></tr></table></figure></p>
<p>另一个<code>getMethods()</code>方法也可以获取到类和接口的所有方法，与上面方法不同的是调用这个方法只会返回定义为 public 的 Method 对象，包括继承的方法。</p>
<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>有两种方法可以创建实例，第一种是直接通过 class 对象的 newInstance 创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class clsA = Class.forName(<span class="string">"com.djp.demo.Student"</span>);</div><div class="line">clsA.newInstance();</div></pre></td></tr></table></figure></p>
<p>第二种通过构造器创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Constructor constructor = cls.getConstructor(<span class="keyword">int</span>.class, String.class, String.class);</div><div class="line">Student student = (Student) constructor.newInstance(<span class="number">18</span>, <span class="string">"lucien"</span>, <span class="string">"man"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="通过-name-调用方法"><a href="#通过-name-调用方法" class="headerlink" title="通过 name 调用方法"></a>通过 name 调用方法</h3><p>首先根据 name 获取到 Method 对象，然后调用 invoke 方法传入对应参数就可以调用方法了，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method method = cls.getMethod(<span class="string">"getAge"</span>);</div><div class="line">method.invoke(<span class="keyword">new</span> Student(<span class="number">22</span>,<span class="string">"lucien"</span>,  <span class="string">"man"</span>));</div></pre></td></tr></table></figure></p>
<h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><p>通过调用 <code>getDeclaredFields()</code> 或者 <code>getFields()</code>，方法区别和获取方法类似。</p>
]]></content>
    
    <summary type="html">
    
      对 Java 反射机制的简要总结。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags%C3%9F/Java/"/>
    
  </entry>
  
</feed>
