<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucien</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-12T11:01:50.380Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lucien</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HandlerThread原理探析</title>
    <link href="http://yoursite.com/2019/10/12/HandlerThread%E5%8E%9F%E7%90%86%E6%8E%A2%E6%9E%90/"/>
    <id>http://yoursite.com/2019/10/12/HandlerThread原理探析/</id>
    <published>2019-10-12T11:01:50.000Z</published>
    <updated>2019-10-12T11:01:50.380Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java反射机制</title>
    <link href="http://yoursite.com/2018/08/11/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/11/Java反射机制/</id>
    <published>2018-08-11T13:53:45.000Z</published>
    <updated>2018-08-19T07:32:30.887Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><blockquote>
<p>Reflection is a feature in the Java programming language. It allows an executing Java program to examine or “introspect” upon itself, and manipulate internal properties of the program. For example, it’s possible for a Java class to obtain the names of all its members and display them. — <a href="https://www.oracle.com/technetwork/articles/java/javareflection-1536171.html" target="_blank" rel="external">from oracle</a></p>
</blockquote>
<p>大致意思是反射是 Java 语言的特性之一，它允许一个运行中的 Java 程序去获取自身的信息并操作它们。</p>
<p>首先我们定义一个 Student 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">int</span> age;</div><div class="line">	<span class="keyword">protected</span> String name;</div><div class="line">	<span class="keyword">public</span> String gender;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</div><div class="line">		</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> age, String name, String gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.age = age;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> gender;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gender)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.gender = gender;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>获取 Class 对象有如下三种方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Class clsA = Class.forName(<span class="string">"com.djp.demo.Student"</span>);</div><div class="line">Class clsB = Student.class;</div><div class="line">Class clsC = <span class="keyword">new</span> Student().getClass();</div></pre></td></tr></table></figure></p>
<h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getMethods</span><span class="params">(Class cls)</span> </span>&#123;</div><div class="line">	Method[] methods = cls.getDeclaredMethods();</div><div class="line">	<span class="keyword">for</span> (Method method : methods) &#123;</div><div class="line">		System.out.println(method.toString());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过<code>getDeclaredMethods()</code>方法可以返回类或者接口的所有方法，包括 public, protected, defalut, and private，但无法获取到继承的方法。打印信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public java.lang.String com.djp.demo.Student.getName()</div><div class="line">public void com.djp.demo.Student.setName(java.lang.String)</div><div class="line">public int com.djp.demo.Student.getAge()</div><div class="line">public java.lang.String com.djp.demo.Student.getGender()</div><div class="line">public void com.djp.demo.Student.setGender(java.lang.String)</div><div class="line">public void com.djp.demo.Student.setAge(int)</div></pre></td></tr></table></figure></p>
<p>另一个<code>getMethods()</code>方法也可以获取到类和接口的所有方法，于上面方法不同的是调用这个方法只会返回定义为 public 的 Method 对象，包括继承的方法。</p>
<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>有两种方法可以创建实例，第一种是直接通过 class 对象的 newInstance 创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Class clsA = Class.forName(<span class="string">"com.djp.demo.Student"</span>);</div><div class="line">clsA.newInstance();</div></pre></td></tr></table></figure></p>
<p>第二种通过构造器创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Constructor constructor = cls.getConstructor(<span class="keyword">int</span>.class, String.class, String.class);</div><div class="line">Student student = (Student) constructor.newInstance(<span class="number">18</span>, <span class="string">"lucien"</span>, <span class="string">"man"</span>);</div></pre></td></tr></table></figure></p>
<h3 id="通过-name-调用方法"><a href="#通过-name-调用方法" class="headerlink" title="通过 name 调用方法"></a>通过 name 调用方法</h3><p>首先根据 name 获取到 Method 对象，然后调用 invoke 方法传入对应参数就可以调用方法了，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Method method = cls.getMethod(<span class="string">"getAge"</span>);</div><div class="line">method.invoke(<span class="keyword">new</span> Student(<span class="number">22</span>,<span class="string">"lucien"</span>,  <span class="string">"man"</span>));</div></pre></td></tr></table></figure></p>
<h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><p>通过调用 <code>getDeclaredFields()</code> 或者 <code>getFields()</code>，方法区别和获取方法类似。</p>
]]></content>
    
    <summary type="html">
    
      对 Java 反射机制的简要总结。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags%C3%9F/Java/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务学习笔记</title>
    <link href="http://yoursite.com/2018/08/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/08/09/数据库事务学习笔记/</id>
    <published>2018-08-09T13:17:28.000Z</published>
    <updated>2018-08-09T14:16:23.351Z</updated>
    
    <content type="html"><![CDATA[<p>数据库事务（简称事务）：是数据库管理系统（Database Managment System 简称DBMS）执行过程中的一个逻辑单位，是由有限的数据库操作序列构成。</p>
<p>事务的特性：</p>
<ul>
<li>原子性：事务作为一个整体执行，包含在其中的数据库操作要么全部执行，要么不执行。</li>
<li>一致性：事务要确保数据库由一个一致性的状态变成另一个一致性的状态。</li>
<li>隔离性：允许多个事务并发进行，并且执行过程中一个事务不应受另外一个事务影响。</li>
<li>持久性：已经提交的事务对数据库的修改应该永远保存在数据库中。</li>
</ul>
<p>事务的四种隔离：</p>
<ul>
<li>读未提交（Read uncommitted）：允许“脏读”，即事务可以读到其它事务还未提交的修改。</li>
<li>读已提交（Read committed）：只能读取到已经提交的数据。</li>
<li>可重复读（Repeatable reads）：即在事务中的查询和开始是一致的。</li>
<li>可串形化（Serializable）：在基于锁机制并发控制的DBMS实现可串行化，要求在选定对象上的读锁和写锁保持直到事务结束后才能释放。在SELECT的查询中使用一个“WHERE”子句来描述一个范围时应该获得一个“范围锁”（range-locks）。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      本文主要是学习数据库事务时的笔记。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="database" scheme="http://yoursite.com/tags%C3%9F/database/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 排序算法之插入排序</title>
    <link href="http://yoursite.com/2018/06/09/%E9%87%8D%E6%8B%BE-DSA-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/06/09/重拾-DSA-排序算法之插入排序/</id>
    <published>2018-06-09T07:50:47.000Z</published>
    <updated>2018-06-09T08:22:27.075Z</updated>
    
    <content type="html"><![CDATA[<p>wikipedia:</p>
<blockquote>
<p>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
</blockquote>
<p>意思就是从输入的元素里每次取出一个插入到有序的列表中，直到取完所有的元素为止。<br><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt=""></p>
<p>以下是代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; array.length - <span class="number">1</span>; i++) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt; <span class="number">0</span>; j--) &#123;</div><div class="line">			<span class="keyword">if</span>(array[j - <span class="number">1</span>] &lt;= array[j])</div><div class="line">				<span class="keyword">break</span>;</div><div class="line">			<span class="keyword">int</span> temp = array[j - <span class="number">1</span>];</div><div class="line">			array[j - <span class="number">1</span>] = array[j];</div><div class="line">			array[j] = temp;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>算法的时间复杂度为 O(n^2)。</p>
]]></content>
    
    <summary type="html">
    
      关于插入排序的介绍和 Java 实现。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 排序算法之简单选择排序</title>
    <link href="http://yoursite.com/2018/05/31/%E9%87%8D%E6%8B%BE-DSA-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/31/重拾-DSA-排序算法之简单选择排序/</id>
    <published>2018-05-31T09:18:26.000Z</published>
    <updated>2018-05-31T09:41:01.129Z</updated>
    
    <content type="html"><![CDATA[<p>wikipedia:</p>
<blockquote>
<p>The algorithm divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right.</p>
</blockquote>
<p>概括就是将数列分为两部分，分别是排好序和未排好序部分，每次取未排序部分的最大值或者最小值，放到已排序部分的数列中。</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif" alt=""></p>
<p>以下是代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">simpleSelectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; array.length; j++) &#123;</div><div class="line">			<span class="keyword">if</span>(array[i] &gt; array[j]) &#123;</div><div class="line">				<span class="keyword">int</span> temp = array[i];</div><div class="line">				array[i] = array[j];</div><div class="line">				array[j] = temp;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该算法的时间复杂度为 O(n^2)。</p>
]]></content>
    
    <summary type="html">
    
      关于简答选择排序的简单介绍和 Java 实现。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 排序算法之快速排序</title>
    <link href="http://yoursite.com/2018/05/29/%E9%87%8D%E6%8B%BE-DSA-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/29/重拾-DSA-排序算法之快速排序/</id>
    <published>2018-05-29T08:23:15.000Z</published>
    <updated>2018-06-09T08:25:27.626Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序的主要运用的就是分治的思想。</p>
<blockquote>
<p>The steps are:</p>
</blockquote>
<p>1.Pick an element, called a pivot, from the array.</p>
<p>2.Partitioning: reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this partitioning, the pivot is in its final position. This is called the partition operation.</p>
<p>3.Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values.</p>
<p>上面是 wiki 中定义的步骤，其实就是先找一个 pivot，一般我们设定数组的第一个或者最后一个元素为 pivot，把数组中小于 pivot 的元素移到左边，大于 pivot 的元素移到右边，然后以同样的方式再对左右两边的子数组操作，最后就会得到一个有序数组。</p>
<p>sample:<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/a/af/Quicksort-diagram.svg/200px-Quicksort-diagram.svg.png" alt=""> </p>
<p>以下是代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> l = low;</div><div class="line">	<span class="keyword">int</span> h = high;</div><div class="line">	<span class="keyword">if</span>(l &gt;= h)</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	<span class="keyword">int</span> pivot = array[high];</div><div class="line">	<span class="keyword">while</span>(l &lt; h) &#123;</div><div class="line">		<span class="keyword">while</span>(array[l] &gt; pivot &amp;&amp; l &lt; h) &#123;</div><div class="line">			<span class="keyword">int</span> temp = array[h - <span class="number">1</span>];</div><div class="line">			array[h] = array[l];</div><div class="line">			array[l] = temp;</div><div class="line">			h--;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">while</span>(array[l] &lt;= pivot &amp;&amp; l &lt; h) &#123;</div><div class="line">			l++;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	array[l] = pivot;</div><div class="line">	sort(array, low, l - <span class="number">1</span>);</div><div class="line">	sort(array, l + <span class="number">1</span>, high);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>快速排序的平均复杂度为 O(nlogn),最差情况下为 O(n^2)。</p>
]]></content>
    
    <summary type="html">
    
      关于快速排序的简单介绍和 Java 实现。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>设计模式原则</title>
    <link href="http://yoursite.com/2018/05/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2018/05/28/设计模式原则/</id>
    <published>2018-05-27T20:40:42.000Z</published>
    <updated>2018-05-27T20:57:12.181Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li>单一职责原则(Single Responsibility Principle): 就一个类而言，应该只有一个引起它变化的原因。</li>
<li>开闭原则(Open-Closed Principle): 一个软件实体应当对扩展开放，对修改关闭。</li>
<li>里氏替换原则(Liskov Substitution Principle): 所有引用基类（父类）的地方必须能透明地使用其子类的对象。</li>
<li>依赖倒置原则(Dependency Inversion  Principle): 针对接口编程，而不是针对实现编程。</li>
<li>接口隔离原则(Interface  Segregation Principle): 使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。</li>
<li>迪米特法则(Law of  Demeter): 一个软件实体应当尽可能少地与其他实体发生相互作用。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;单一职责原则(Single Responsibility Principle): 就一个类而言，应该只有一个引起它变化的原因。&lt;/li&gt;
&lt;li&gt;开闭原则(Open-Closed Principle): 一个软件实体应当对扩展开放，对修改关闭。&lt;/li&gt;
&lt;li
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags%C3%9F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 排序算法之冒泡排序</title>
    <link href="http://yoursite.com/2018/05/23/%E9%87%8D%E6%8B%BE-DSA-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2018/05/23/重拾-DSA-排序算法之冒泡排序/</id>
    <published>2018-05-23T10:36:06.000Z</published>
    <updated>2019-10-12T10:59:25.582Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于冒泡排序的概括：</p>
<blockquote>
<p>Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. The algorithm, which is a comparison sort, is named for the way smaller or larger elements “bubble” to the top of the list. Although the algorithm is simple, it is too slow and impractical for most problems even when compared to insertion sort.[2] Bubble sort can be practical if the input is in mostly sorted order with some out-of-order elements nearly in position.</p>
</blockquote>
<p>简而言之呢就是相领元素的比较，下面还是来自 wikipedia 的一张图，很直观了：<br><img src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" alt=""> </p>
<p>不妨假设我们有这样一个数组<code>int list[] = {5, 1, 4, 2, 8};</code><br>那么冒泡排序的步骤就如下:</p>
<p>第一趟：<br>{<strong>5</strong>, <strong>1</strong>, 4, 2, 8} -&gt; {<strong>1</strong>, <strong>5</strong>, 4, 2, 8}, 5 &gt; 1, 交换位置;<br>{1, <strong>5</strong>, <strong>4</strong>, 2, 8} -&gt; {1, <strong>4</strong>, <strong>5</strong>, 2, 8}, 5 &gt; 4, 交换位置;<br>{1, 4, <strong>5</strong>, <strong>2</strong>, 8} -&gt; {1, 4, <strong>2</strong>, <strong>5</strong>, 8}, 5 &gt; 2, 交换位置;<br>{1, 4, 2, <strong>5</strong>, <strong>8</strong>} -&gt; {1, 4, 2, <strong>5</strong>, <strong>8</strong>}, 5 &lt; 8, 位置不变;<br>所以第一趟排序下来的数组顺序是 {1, 4, 2, 5, 8}，此时数组中最大的数 <strong>8</strong> 已经在末尾。</p>
<p>第二趟：<br>{<strong>1</strong>, <strong>4</strong>, 2, 5, 8} -&gt; {<strong>1</strong>, <strong>4</strong>, 2, 5, 8}, 1 &lt; 4, 位置不变;<br>{1, <strong>4</strong>, <strong>2</strong>, 5, 8} -&gt; {1, <strong>2</strong>, <strong>4</strong>, 5, 8}, 4 &gt; 2, 交换位置;<br>{1, 2, <strong>4</strong>, <strong>5</strong>, 8} -&gt; {1, 2, <strong>4</strong>, <strong>5</strong>, 8}, 4 &lt; 5, 位置不变;<br>第二趟排序下来数组中第二大的数已经在倒数第二的位置。</p>
<p>第三趟：<br>{<strong>1</strong>, <strong>2</strong>, 4, 5, 8} -&gt; {<strong>1</strong>, <strong>2</strong>, 4, 5, 8}, 1 &lt; 2, 位置不变;<br>{1, <strong>2</strong>, <strong>4</strong>, 5, 8} -&gt; {1, <strong>2</strong>, <strong>4</strong>, 5, 8}, 2 &lt; 4, 位置不变;</p>
<p>第四趟：<br>{<strong>1</strong>, <strong>2</strong>, 4, 5, 8} -&gt; {<strong>1</strong>, <strong>2</strong>, 4, 5, 8}, 1 &lt; 2, 位置不变;</p>
<p>以下是代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] list) &#123;</div><div class="line">		<span class="keyword">int</span> length = list.length;</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</div><div class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length - i - <span class="number">1</span>; j++) &#123;</div><div class="line">				<span class="keyword">if</span>(list[j] &gt; list[j + <span class="number">1</span>]) &#123;</div><div class="line">					<span class="keyword">int</span> temp = list[j];</div><div class="line">					list[j] = list[j + <span class="number">1</span>];</div><div class="line">					list[j + <span class="number">1</span>] = temp;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">return</span> list;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>冒泡排序的效率并不高，时间复杂度为 O(n^2)；</p>
]]></content>
    
    <summary type="html">
    
      面试手写冒泡排序写错了，惭愧。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Android抽象布局</title>
    <link href="http://yoursite.com/2018/05/20/Android%E6%8A%BD%E8%B1%A1%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2018/05/20/Android抽象布局/</id>
    <published>2018-05-20T10:03:24.000Z</published>
    <updated>2018-05-20T10:03:51.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-lt-include-gt-标签"><a href="#1-lt-include-gt-标签" class="headerlink" title="1.&lt;include /&gt; 标签"></a>1.&lt;include /&gt; 标签</h3><p>&lt;include /&gt; 标签主要解决布局重用的问题，在我们大多数的 app 中的标题栏布局都是相似的，这个时候就可以用 &lt;include /&gt; 标签重用布局文件了。使用方法如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">	<span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">	<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">	<span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">	<span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</div><div class="line"></div><div class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">layout</span>=<span class="string">"@layout/include_head"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="2-lt-merge-gt-标签"><a href="#2-lt-merge-gt-标签" class="headerlink" title="2.&lt;merge /&gt; 标签"></a>2.&lt;merge /&gt; 标签</h3><p>&lt;merge /&gt; 标签的作用可以减少 UI 的层级，假如要在主布局 LinearLayout 中引入同样是 LinearLayout 的 include 布局，那么便可以将引入布局的最外层布局设置为 &lt;merge /&gt; 标签，这样系统将会自动忽略 &lt;merge /&gt; 节点，从而达到减少布局层次的目的。比如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">merge</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"hello"</span> /&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:text</span>=<span class="string">"world"</span> /&gt;</div><div class="line">    </div><div class="line"><span class="tag">&lt;/<span class="name">merge</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="3-lt-ViewStub-gt-标签"><a href="#3-lt-ViewStub-gt-标签" class="headerlink" title="3.&lt;ViewStub /&gt; 标签"></a>3.&lt;ViewStub /&gt; 标签</h3><p>&lt;ViewStub /&gt; 标签的作用就是延迟加载布局资源，从而达到加快 UI 初始化速度目的，适用场景如进度条，加载失败布局等一些一开始不需要加载的布局。如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">android.support.constraint.ConstraintLayout</span> </span></div><div class="line">    <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></div><div class="line">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></div><div class="line">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></div><div class="line">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">    <span class="attr">tools:context</span>=<span class="string">"com.juhe.generaldemo.MainActivity"</span>&gt;</div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">ViewStub</span></span></div><div class="line">        <span class="attr">android:id</span>=<span class="string">"@+id/viewstub"</span></div><div class="line">        <span class="attr">android:layout</span>=<span class="string">"@layout/viewstub_layout"</span></div><div class="line">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span> /&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">android.support.constraint.ConstraintLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>想要加载布局时：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ViewStub viewStub = (ViewStub) findViewById(R.id.viewstub);</div><div class="line">viewStub.inflate();</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      简单介绍 Android 中 &amp;lt;include /&amp;gt;、 &amp;lt;merge /&amp;gt; 和 &amp;lt;ViewStub /&amp;gt; 标签的使用。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>2017 年终总结</title>
    <link href="http://yoursite.com/2018/01/01/2017%E5%B9%B4%E7%9A%84%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/01/01/2017年的年终总结/</id>
    <published>2018-01-01T09:49:30.000Z</published>
    <updated>2018-03-05T08:07:38.643Z</updated>
    
    <content type="html"><![CDATA[<!-- 本来打算不写的，可是想了想不总结似乎有些过不去，就好像是个习惯，很难改变，那就简单写写过去的一年吧。

2017 年可以按时间分割为两部分，八月中旬我辞去了在多少的工作，然后就来到了炬合网络，为什么要辞职呢，这个我之前已经[写过](https://www.dujianping.com/2017/08/17/%E7%A6%BB%E8%81%8C/)，这里就不再重述了，我想接下来还是主要写一些关于炬合的事。炬合这家公司给我的第一印象似乎是不靠谱的，从在 boss 上忠哥没有仔细看我简历就让我去面试，到去面试的时候发现公司空荡荡几乎没有看到啥人，我特别犹豫不决，回来的时候我再看看简介原来是三个浙大一起创业的公司，好感度增加了点，忠哥初面之后大概第二天吧就通知我去复试，复试我的是邵总，印象还挺好的，当时给我介绍了一些关于公司的情况啥的，说完我还挺期待，当时就觉得可以加入，之后就进去了，谁知道三个月之后我面临了裁员。初进炬合便立马参与进现金斗士这个项目里了，然后开始疯狂的加班，每天晚上加班到九点半之后，周六也加班，国庆也加班，这种状态大概持续了一个多月吧，随着项目渐渐地完成，工作的安排也正常起来了，几乎是不用加班的。虽然加班多，工作强度大，大到我记得第一个 iOS 来了一个星期就走了，但我挺开心的，尤其是遇到了这些同事，忠哥、小罗、夏哲、文斌、小敏、小布、姚佳还有其他人，我就觉得和他们一起工作特别舒服，似乎每天都过得很有意思，那时候我就在想如果我们这群人把这件事做成了，那人生就相当圆满了，可是现实总是事与愿违。一开始内心有挣扎是在安卓 app 上架时期，那个时候因为资质的问题我们有些渠道，包括应用宝在内的大渠道上不去，按照我的逻辑当然没有资质就去申请资质嘛，大概是因为炬合无法满足这些要求，小布就搞了些假资质尝试上线，那个时候稍微有些不爽了，之后是现金斗士返利版，很随意的一个产品，再后来也就基本没啥特别的事了，监管政策下来，现金贷业务叫停，过了几周就让我们走人了，就这样第一次体验到了商业社会的残酷。

没有后悔离开多少，因为不这样做，我会一直陷于泥潭之中；更没有后悔加入炬合，虽然最后还是散了，但我遇到了很多有意思的人，收获了友谊，当然还有自我成长，这也是最重要的。

2018 年等待我去完成的第一件事就是找工作，我想这次就直奔我心心念念好久的上海去了吧，希望在这一年里能养成些新的好习惯，增加点体重，成为更好的自己，good luck～ -->
]]></content>
    
    <summary type="html">
    
      本来打算不写的，可是想了想不总结似乎有些过不去，就好像是个习惯，很难改变，那就简单写写过去的一年吧。
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随想" scheme="http://yoursite.com/tags%C3%9F/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>2months</title>
    <link href="http://yoursite.com/2017/11/14/2months/"/>
    <id>http://yoursite.com/2017/11/14/2months/</id>
    <published>2017-11-14T06:53:43.000Z</published>
    <updated>2017-11-14T07:11:20.751Z</updated>
    
    <content type="html"><![CDATA[<p>前些天有个许久未联系的朋友微信发来问候“最近身体还好吧？”，我当时有种哭笑不得的感觉，然后今天感冒了，现在看来多像“善意的诅咒”啊。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前些天有个许久未联系的朋友微信发来问候“最近身体还好吧？”，我当时有种哭笑不得的感觉，然后今天感冒了，现在看来多像“善意的诅咒”啊。&lt;/p&gt;

    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随想" scheme="http://yoursite.com/tags%C3%9F/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 之树</title>
    <link href="http://yoursite.com/2017/08/19/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E6%A0%91/"/>
    <id>http://yoursite.com/2017/08/19/重拾-DSA-之树/</id>
    <published>2017-08-19T01:50:40.000Z</published>
    <updated>2018-12-23T04:33:30.678Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于树的定义：</p>
<blockquote>
<p><strong>树</strong>（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>
<ul>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ul>
</blockquote>
<h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><p><strong>节点的度</strong>：一个节点含有的子树的个数称为该节点的度；<br><strong>树的度</strong>：一棵树中最大的节点的度称为树的度；<br><strong>叶子结点</strong>：度为零的节点；<br><strong>分支节点</strong>：度不为零的节点；<br><strong>父节点</strong>：若一个节点含有字节点，则这个节点称为该字节点的父节点；<br><strong>子节点</strong>：一个节点含有的子树的根节点称为该节点的字节点；<br><strong>兄弟节点</strong>：具有相同父节点的节点称为兄弟节点；<br><strong>节点的层次</strong>：从根开始定义，根为第一层，根的子节点为第2层，以此类推；<br><strong>树的高度或深度</strong>：树中节点的最大层次；<br><strong>堂兄弟节点</strong>：父节点在同一层的节点互为堂兄弟；<br><strong>节点的祖先</strong>：从根到该节点所经分支上的所有节点；<br><strong>子孙</strong>：以某节点为根的子树中任一节点都称为该节点的子孙；<br><strong>森林</strong>：由 m（m &gt;= 0）棵互不相交的树的结合成为森林；<br><img src="http://wx2.sinaimg.cn/large/9302210cly1fyghx5gzzej207t07j74a.jpg" alt=""><br>如上图 B 节点的度为 2，C 的度为 1，整棵树的高度为 2。这棵树的叶子结点有 D、G、F，剩下的是分支节点。A 是 B 的父节点，A 是 C 的父节点，B 和 C 是兄弟节点。A 节点的层次为 1， B 节点的层次为 2，D 节点的层次为 3，树的高度为 3， D、E、F互为堂兄弟。</p>
<h3 id="树的种类"><a href="#树的种类" class="headerlink" title="树的种类"></a>树的种类</h3><p>树的种类可以分为两种，分别是<strong>无序树</strong>和<strong>有序树</strong>。无序树树中任意节点的子节点之间没有顺序关系，无序树也可以称为自由树；有序树表示树中任意节点的子节点之间有顺序关系。</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是属于有序树中的一种，每个节点最多含有两个字树的树称为二叉树。</p>
<p>三种遍历方式（递归方式）：</p>
<p>先序遍历： 根节点-左节点-右节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</div><div class="line">		System.out.print(node.data + <span class="string">"--&gt;"</span>);</div><div class="line">		preOrder(node.left);</div><div class="line">		preOrder(node.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>中序遍历： 左节点-根节点-右节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</div><div class="line">		inOrder(node.left);</div><div class="line">		System.out.print(node.data + <span class="string">"--&gt;"</span>);</div><div class="line">		inOrder(node.right);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>后续遍历： 左节点-右节点-根节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(node != <span class="keyword">null</span>) &#123;</div><div class="line">		postOrder(node.left);</div><div class="line">		postOrder(node.right);</div><div class="line">		System.out.print(node.data + <span class="string">"--&gt;"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><a href="https://github.com/lucien623/DSA_Review/blob/master/BinaryTree.java" target="_blank" rel="external">Source Code</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是 wikipedia 对于树的定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;树&lt;/strong&gt;（英语：tree）是一种抽象数据类型（ADT）或是实作这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由 n（n&amp;gt;0）个有限节点
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>离职</title>
    <link href="http://yoursite.com/2017/08/17/%E7%A6%BB%E8%81%8C/"/>
    <id>http://yoursite.com/2017/08/17/离职/</id>
    <published>2017-08-17T15:15:22.000Z</published>
    <updated>2017-08-17T16:05:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>是的，今天正式离职了，又一次裸辞，比预期离开的时间提前了一天。其实我早就有辞职这个想法，也和 leader 交谈过，之前的想法是等找到合适的下家再正式提出，不过工作机会似乎并不多，合适的就更少了，所以一直拖着，直到上上个星期，leader 找我谈话，大概意思就是说如果现在离职就比较好交接，如果接下来要走，就得等他招到人交接完才能走，再三考虑之后，我决定离开。</p>
<p>说说要离开的理由吧。主要有两个原因，首先我觉得这个项目已经不太有可能会起来了，其次是待遇问题。</p>
<p>对于这次裸辞，我并没觉得自己是任性的，这是理性选择的结果，对于这段工作经历，我还没有仔细总结过，反正在怎么样给人画大饼上我是深有体会了。</p>
<p>接下来就是找新工作的事情了，送给自己八个字：全力以赴，慎重选择。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是的，今天正式离职了，又一次裸辞，比预期离开的时间提前了一天。其实我早就有辞职这个想法，也和 leader 交谈过，之前的想法是等找到合适的下家再正式提出，不过工作机会似乎并不多，合适的就更少了，所以一直拖着，直到上上个星期，leader 找我谈话，大概意思就是说如果现在离
    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="随想" scheme="http://yoursite.com/tags%C3%9F/%E9%9A%8F%E6%83%B3/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 之队列</title>
    <link href="http://yoursite.com/2017/08/12/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2017/08/12/重拾-DSA-之队列/</id>
    <published>2017-08-12T08:40:19.000Z</published>
    <updated>2017-08-12T08:55:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于队列的定义：</p>
<blockquote>
<p><strong>队列</strong>又称为伫列（queue），是先进先出（FIFO, First In First Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</p>
</blockquote>
<p>队列和栈十分相似，不同点在于栈是 Last In First Out，而队列是 First In First Out。</p>
<p>这里使用 LinkedList 存储数据。</p>
<ul>
<li>添加一个元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">	mList.addLast(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>移除元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(!mList.isEmpty()) &#123;</div><div class="line">		mList.removeFirst();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取队列元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> T <span class="title">getHead</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> mList.getFirst();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/lucien623/DSA_Review/blob/master/Queue.java" target="_blank" rel="external">Source Code</a></p>
]]></content>
    
    <summary type="html">
    
      本文主要介绍了队列的基本知识。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重拾 DSA 之栈</title>
    <link href="http://yoursite.com/2017/08/12/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E6%A0%88/"/>
    <id>http://yoursite.com/2017/08/12/重拾-DSA-之栈/</id>
    <published>2017-08-12T08:15:03.000Z</published>
    <updated>2017-08-12T08:47:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于栈的定义：</p>
<blockquote>
<p><strong>堆栈</strong> （英语：stack），也可直接称栈（港澳台作堆叠），在计算机科学中，是一种特殊的串列形式的数据结构，它的特殊之处在于只能允许在链接串列或阵列的一端（称为堆叠顶端指标，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外栈也可以用一维数组或连结串列的形式来完成。<br>由于堆叠数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。</p>
</blockquote>
<p>简单示意图：<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/2/29/Data_stack.svg/391px-Data_stack.svg.png" alt=""></p>
<p>这里使用 LinkedList 存储数据。</p>
<ul>
<li>入栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">	mList.addFirst(t);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>出栈</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(!mList.isEmpty()) &#123;</div><div class="line">		mList.removeFirst();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>获取栈顶元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getPop</span><span class="params">()</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> mList.getFirst();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://github.com/lucien623/DSA_Review/blob/master/Stack.java" target="_blank" rel="external">Source Code</a></p>
]]></content>
    
    <summary type="html">
    
      本文主要介绍了栈的基本知识。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>重拾  DSA 之链表</title>
    <link href="http://yoursite.com/2017/08/11/%E9%87%8D%E6%8B%BE-DSA-%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2017/08/11/重拾-DSA-之链表/</id>
    <published>2017-08-11T07:40:59.000Z</published>
    <updated>2017-08-12T08:23:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面是 wikipedia 对于链表的定义：</p>
<blockquote>
<p><strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到   O(1) 的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要 O(n) 的时间，而顺序表相应的时间复杂度分别是O(logn) 和 O(1)。</p>
</blockquote>
<ul>
<li>添加<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object data)</span> </span>&#123;</div><div class="line">	<span class="comment">//如果头节点为空，则创建一个新节点，并将其设置为头节点以及当前节点。</span></div><div class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;</div><div class="line">		head = <span class="keyword">new</span> Node(data);</div><div class="line">		current = head;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">else</span> &#123;</div><div class="line">		current.next = <span class="keyword">new</span> Node(data);</div><div class="line">		current = current.next;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>插入<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> index, Object data)</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">if</span>(index == <span class="number">0</span>) &#123;</div><div class="line">		head = <span class="keyword">new</span> Node(data);</div><div class="line">		head.next = current;</div><div class="line">		<span class="keyword">return</span>;</div><div class="line">	&#125;</div><div class="line">	Node preNode = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>((<span class="keyword">int</span>)current.data == index) &#123;</div><div class="line">			Node node = <span class="keyword">new</span> Node(data);</div><div class="line">			preNode.next = node;</div><div class="line">			node.next = current;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		preNode = current;</div><div class="line">		current = current.next;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>删除<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">	Node preNode = head;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(pos == index) &#123;</div><div class="line">			<span class="keyword">if</span>(pos == <span class="number">0</span>)</div><div class="line">				head = current.next;</div><div class="line">			<span class="comment">//判断当前节点是否还有下一个节点，有则将前一个节点的next指向下一个节点，</span></div><div class="line">			<span class="comment">//无则将前一个节点的next指向设置为null</span></div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				<span class="keyword">if</span>(current.next != <span class="keyword">null</span>) &#123;</div><div class="line">					preNode.next = current.next;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					preNode.next = <span class="keyword">null</span>;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">return</span>;</div><div class="line">		&#125;</div><div class="line">		preNode = current;</div><div class="line">		current = current.next;</div><div class="line">		pos++;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>查找<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">int</span> pos = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(index == pos) &#123;</div><div class="line">			<span class="keyword">return</span> current;</div><div class="line">		&#125;</div><div class="line">		current = current.next;</div><div class="line">		pos++;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>获取链表中节点的个数<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getLinkListLength</span><span class="params">()</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">int</span> length = <span class="number">0</span>;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		length++;</div><div class="line">		current = current.next;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>链表反转<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reverseLinkList</span><span class="params">()</span> </span>&#123;</div><div class="line">	current = head;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		Node preHead = reverseHead;</div><div class="line">		reverseHead = current;</div><div class="line">		current = current.next;</div><div class="line">		<span class="keyword">if</span>(preHead != <span class="keyword">null</span>) &#123;</div><div class="line">			reverseHead.next = preHead;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			reverseHead.next = <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>链表反转（递归方式）<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">reverseLinkListRec</span><span class="params">(Node head)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</div><div class="line">		<span class="keyword">return</span> head;</div><div class="line">	Node newHead = reverseLinkListRec(head.next);</div><div class="line">	head.next.next = head;</div><div class="line">	head.next = <span class="keyword">null</span>;</div><div class="line">	<span class="keyword">return</span> newHead;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>获取倒数第 index 节点（先让当前节点移动到第 index 个节点，再创建一个节点 start 指向头节点，当前节点和 start 节点同时移动，当当前节点移动到最后一个节点时，start 指向的便是倒数第 index 节点）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">getReciprocalNode</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">	<span class="keyword">if</span>(index == <span class="number">0</span>)</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	current = head;</div><div class="line">	Node start = head;</div><div class="line">	<span class="keyword">while</span>(current != <span class="keyword">null</span>) &#123;</div><div class="line">		index--;</div><div class="line">		<span class="keyword">if</span>(index == <span class="number">0</span>)</div><div class="line">			<span class="keyword">break</span>;</div><div class="line">		current = current.next;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 长度大于链表长度</span></div><div class="line">	<span class="keyword">if</span>(current == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(current.next != <span class="keyword">null</span>) &#123;</div><div class="line">		current = current.next;</div><div class="line">		start = start.next;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> start;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>获取链表的中间节点(初始化两个节点都指向头节点，一个节点每次移动一个节点，另一个每次移动两个节点，当第二个节点移动到链表末尾时，第一个节点指向的节点即是链表的中间节点)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">private</span> Node <span class="title">getMiddleNode</span><span class="params">()</span> </span>&#123;</div><div class="line">	Node oneStepNode = head;</div><div class="line">	Node twoStepNode = head;</div><div class="line">	<span class="comment">//加入小于三个节点则返回第一个节点作为中间节点</span></div><div class="line">	<span class="keyword">if</span>(head.next == <span class="keyword">null</span> || head.next.next == <span class="keyword">null</span>) &#123;</div><div class="line">		<span class="keyword">return</span> current;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">while</span>(twoStepNode.next != <span class="keyword">null</span> &amp;&amp; twoStepNode.next.next != <span class="keyword">null</span>) &#123;</div><div class="line">		twoStepNode = twoStepNode.next.next;</div><div class="line">		oneStepNode = oneStepNode.next;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> oneStepNode;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><a href="https://github.com/lucien623/DSA_Review/blob/master/LinkList.java" target="_blank" rel="external">Source Code</a></p>
]]></content>
    
    <summary type="html">
    
      本文主要介绍了链表的一些操作。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="DSA" scheme="http://yoursite.com/tags%C3%9F/DSA/"/>
    
  </entry>
  
  <entry>
    <title>Android事件分发</title>
    <link href="http://yoursite.com/2017/07/11/android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    <id>http://yoursite.com/2017/07/11/android事件分发/</id>
    <published>2017-07-11T09:06:00.000Z</published>
    <updated>2018-12-23T04:33:31.575Z</updated>
    
    <content type="html"><![CDATA[<p>Android 中和事件分发相关的主要有三个方法，分别是 dispatchTouchEvent(…)、onInterceptTouchEvent(…) 和 onTouchEvent(…)，主要作用是分发事件、是否拦截事件以及处理事件，这些方法的返回值决定了 Touch 事件的传递方向，方法的包涵情况具体如下表所示：</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">dispatchTouchEvent(…)</th>
<th style="text-align:center">onInterceptTouchEvent(…)</th>
<th style="text-align:center">onTouchEvent(…)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Activity</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td>ViewGroup</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">yes</td>
</tr>
<tr>
<td>view</td>
<td style="text-align:center">yes</td>
<td style="text-align:center">no</td>
<td style="text-align:center">yes</td>
</tr>
</tbody>
</table>
<p>以下为事件分发流程图（针对于 ACTION_DOWN 事件，可点击查看大图）</p>
<!-- touchevent.png -->
<p><img src="http://wx4.sinaimg.cn/large/9302210cly1fygi1siu3qj21ex0t876w.jpg" alt=""></p>
<p>如图所示的事件传递流向已十分清晰，demo 也十分易写，只需自行重写这些方法，打印日志便可验证。</p>
<p>对于 ACTION_MOVE 和 ACTION_UP 事件的传递则略有不同，它们的传递和 ACTION_DOWN 事件传递的终点相关，以下举例。</p>
<h4 id="1）在-View-的-onTouchEvent-消费事件，即-return-true。"><a href="#1）在-View-的-onTouchEvent-消费事件，即-return-true。" class="headerlink" title="1）在 View 的 onTouchEvent 消费事件，即 return true。"></a>1）在 View 的 onTouchEvent 消费事件，即 return true。</h4><p>日志：</p>
<!-- touchevent_2_log -->
<p><img src="http://wx3.sinaimg.cn/large/9302210cly1fygi14xf2mj21ww08in3n.jpg" alt=""></p>
<p>事件传递的流向图：</p>
<!-- touchevent_2.png -->
<p><img src="http://wx1.sinaimg.cn/large/9302210cly1fygi18l5huj21gd0u0gt7.jpg" alt=""></p>
<h4 id="2）在-ViewGroup-的-onTouchEvent-…-消费事件，即-return-true。"><a href="#2）在-ViewGroup-的-onTouchEvent-…-消费事件，即-return-true。" class="headerlink" title="2）在 ViewGroup 的 onTouchEvent(…) 消费事件，即 return true。"></a>2）在 ViewGroup 的 onTouchEvent(…) 消费事件，即 return true。</h4><p>日志：</p>
<!-- touchevent_1_log -->
<p><img src="http://wx4.sinaimg.cn/large/9302210cly1fygi0wgpg3j21ww07mq8v.jpg" alt=""></p>
<p>事件传递的流向图：</p>
<!-- touchevent_1 -->
<p><img src="http://wx2.sinaimg.cn/large/9302210cly1fygi10hcufj21gb0u0dn6.jpg" alt=""></p>
<h4 id="3）在-ViewGroup-的-dispatchTouchEvent-…-方法中-return-false。"><a href="#3）在-ViewGroup-的-dispatchTouchEvent-…-方法中-return-false。" class="headerlink" title="3）在 ViewGroup 的 dispatchTouchEvent(…) 方法中 return false。"></a>3）在 ViewGroup 的 dispatchTouchEvent(…) 方法中 return false。</h4><p>日志：</p>
<!-- touchevent_3_log -->
<p><img src="http://wx4.sinaimg.cn/large/9302210cly1fygi1c1kczj21ww044jup.jpg" alt=""></p>
<p>事件传递流向图：</p>
<!-- touchevent_3 -->
<p><img src="http://wx1.sinaimg.cn/large/9302210cly1fygi1oxebij21gh0u0tfs.jpg" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android 中和事件分发相关的主要有三个方法，分别是 dispatchTouchEvent(…)、onInterceptTouchEvent(…) 和 onTouchEvent(…)，主要作用是分发事件、是否拦截事件以及处理事件，这些方法的返回值决定了 Touch 事件
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity生命周期</title>
    <link href="http://yoursite.com/2017/07/10/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://yoursite.com/2017/07/10/Activity生命周期/</id>
    <published>2017-07-10T03:37:39.000Z</published>
    <updated>2017-08-04T05:52:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Activity 是 Android 四大组件之一，它主要给用户提供了一个交互页面，用户通过它与app进行交互，以执行各种操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上（将 Activity 的 theme 设置为 Dialog）。Activity 生命周期中主要的七个回调方法介绍如下表：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>onCreate()</td>
<td>Activity 创建的时候调用,可以在方法里做一些初始化的操作，比如初始化试图，获取从上一个页面传递过来的数据，此时处于不可见状态。</td>
</tr>
<tr>
<td>onRestart()</td>
<td>在 Activity 已停止并即将再次启动前调用。</td>
</tr>
<tr>
<td>onStart()</td>
<td>Activity 处于可见状态，但不能操作，因为并未获取到焦点。</td>
</tr>
<tr>
<td>onResume()</td>
<td>Activity 处于可见状态，并且能够获取到焦点，在 Activity 恢复时可以在此方法中刷新数据。</td>
</tr>
<tr>
<td>onPause()</td>
<td>当系统即将开始继续另一个 Activity 时调用。当此方法执行完才会启动下一个 Activity，此方法中可以做一些停止动画，释放一些资源的操作，但不适合一些比较耗时的操作，因为这样会导致跳转的时候卡顿。</td>
</tr>
<tr>
<td>onStop()</td>
<td>在 Activity 对用户不再可见时调用。如果 Activity 恢复交互，那么接下来会调用 onRestart() 方法，如果 Activity 销毁，那么将会调用 onDestory() 方法。</td>
</tr>
<tr>
<td>onDestory()</td>
<td>在 Activity 被销毁前调用。</td>
</tr>
</tbody>
</table>
<p><img src="https://developer.android.com/images/activity_lifecycle.png" alt="activity-life"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Activity 是 Android 四大组件之一，它主要给用户提供了一个交互页面，用户通过它与app进行交互，以执行各种操作。 每个 Activity 都会获得一个用于绘制其用户界面的窗口。窗口通常会充满屏幕，但也可小于屏幕并浮动在其他窗口之上（将 Activity 的 
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>Activity启动模式</title>
    <link href="http://yoursite.com/2017/07/10/android-review-launchMode/"/>
    <id>http://yoursite.com/2017/07/10/android-review-launchMode/</id>
    <published>2017-07-10T03:13:35.000Z</published>
    <updated>2017-08-04T05:53:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="launchMode"><a href="#launchMode" class="headerlink" title="launchMode"></a>launchMode</h3><ul>
<li><p>standard<br>默认的启动方式，每次都会创建一个活动的实例。<br>task 1: A-B-C-D<br>add D<br>task 1: A-B-C-D-D</p>
</li>
<li><p>singleTop<br>当有活动实例存在于栈顶时，那么将不会生成一个新的活动实例，此时会调用栈顶实例的 onNewIntent() 方法。<br>task 1: A-B-C-D<br>add D<br>task 1: A-B-C-D</p>
</li>
<li><p>singleTask<br>当栈中存在该活动的实例时，那么启动活动时，栈中位于该活动实例上方的活动都将会被移除栈，并调用该活动的 onNewIntent();<br>task 1: A-B-C-D<br>add C<br>task 1: A-B-C</p>
</li>
<li><p>singleInstance<br>启动活动时会创建一个新的栈<br>task 1: A-B-C-D<br>add D<br>task 1: A-B-C-D<br>task 2: D<br>场景：<br>调用相机</p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      简单介绍下在 Android 中的四种 Activity 启动模式。
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="android" scheme="http://yoursite.com/tags%C3%9F/android/"/>
    
  </entry>
  
  <entry>
    <title>开始</title>
    <link href="http://yoursite.com/2017/03/26/%E5%BC%80%E5%A7%8B/"/>
    <id>http://yoursite.com/2017/03/26/开始/</id>
    <published>2017-03-26T12:37:12.000Z</published>
    <updated>2017-07-10T08:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个开始，开始寻找一个新的开始。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一个开始，开始寻找一个新的开始。&lt;/p&gt;

    
    </summary>
    
      <category term="生活" scheme="http://yoursite.com/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
</feed>
